


<!DOCTYPE html>
<html lang="en">
<head>
        <title>Module: measure &mdash; skimage v0.9dev docs</title>
    
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link href="../_static/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../_static/css/custom.css" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">
    
    <script src="http://code.jquery.com/jquery-latest.js"></script>
    <script src="../_static/js/bootstrap.min.js"></script>
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.9dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <link rel="top" title="skimage v0.9dev docs" href="../index.html" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link rel="shortcut icon" href="../_static/favicon.ico">
</head>
<body class="container">
    <a href="http://scikit-image.org" class="logo"><img src="../_static/img/logo.png" alt=""></a>
    <div class="clearfix"></div>
    <div class="navbar">
        <div class="navbar-inner">
            <ul class="nav">
                <li><a href="/">Home</a></li>
<li><a href="/download.html">Download</a></li>
<li><a href="/docs/dev/auto_examples">Gallery</a></li>
<li><a href="/docs/dev">Documentation</a></li>
<li><a href="https://github.com/scikit-image/scikit-image">Source</a></li>
            </ul>
            <form class="navbar-form pull-right" action="../search.html" method="get">
                <input type="text" class="search span3" name="q" placeholder="Search documentation ...">
                <input type="hidden" name="check_keywords" value="yes" >
                <input type="hidden" name="area" value="default" >
            </form>
        </div>
    </div>
    <div class="row">
        <div class="span9">
            
  <div class="section" id="module-skimage.measure">
<span id="module-measure"></span><h1>Module: <tt class="xref py py-mod docutils literal"><span class="pre">measure</span></tt><a class="headerlink" href="#module-skimage.measure" title="Permalink to this headline">¶</a></h1>
<div class="section" id="circlemodel">
<h2><a class="reference internal" href="#skimage.measure.CircleModel" title="skimage.measure.CircleModel"><tt class="xref py py-class docutils literal"><span class="pre">CircleModel</span></tt></a><a class="headerlink" href="#circlemodel" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.measure.CircleModel">
<em class="property">class </em><tt class="descclassname">skimage.measure.</tt><tt class="descname">CircleModel</tt><a class="headerlink" href="#skimage.measure.CircleModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.measure.fit.BaseModel</span></tt></p>
<p>Total least squares estimator for 2D circles.</p>
<p>The functional model of the circle is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">r</span><span class="o">**</span><span class="mi">2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">xc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">yc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>This estimator minimizes the squared distances from all points to the
circle:</p>
<div class="highlight-python"><pre>min{ sum((r - sqrt((x_i - xc)**2 + (y_i - yc)**2))**2) }</pre>
</div>
<p>The <tt class="docutils literal"><span class="pre">_params</span></tt> attribute contains the parameters in the following order:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">r</span>
</pre></div>
</div>
<p>A minimum number of 3 points is required to solve for the parameters.</p>
<dl class="method">
<dt id="skimage.measure.CircleModel.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.measure.CircleModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.measure.CircleModel.estimate">
<tt class="descname">estimate</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#skimage.measure.CircleModel.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate circle model from data using total least squares.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>data</strong> : (N, 2) array</p>
<blockquote class="last">
<div><p>N points with <tt class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span></tt> coordinates, respectively.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.measure.CircleModel.predict_xy">
<tt class="descname">predict_xy</tt><big>(</big><em>t</em>, <em>params=None</em><big>)</big><a class="headerlink" href="#skimage.measure.CircleModel.predict_xy" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict x- and y-coordinates using the estimated model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>t</strong> : array</p>
<blockquote>
<div><p>Angles in circle in radians. Angles start to count from positive
x-axis to positive y-axis in a right-handed system.</p>
</div></blockquote>
<p><strong>params</strong> : (3, ) array, optional</p>
<blockquote>
<div><p>Optional custom parameter set.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>xy</strong> : (..., 2) array</p>
<blockquote class="last">
<div><p>Predicted x- and y-coordinates.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.measure.CircleModel.residuals">
<tt class="descname">residuals</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#skimage.measure.CircleModel.residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine residuals of data to model.</p>
<p>For each point the shortest distance to the circle is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>data</strong> : (N, 2) array</p>
<blockquote>
<div><p>N points with <tt class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span></tt> coordinates, respectively.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>residuals</strong> : (N, ) array</p>
<blockquote class="last">
<div><p>Residual for each data point.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="ellipsemodel">
<h2><a class="reference internal" href="#skimage.measure.EllipseModel" title="skimage.measure.EllipseModel"><tt class="xref py py-class docutils literal"><span class="pre">EllipseModel</span></tt></a><a class="headerlink" href="#ellipsemodel" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.measure.EllipseModel">
<em class="property">class </em><tt class="descclassname">skimage.measure.</tt><tt class="descname">EllipseModel</tt><a class="headerlink" href="#skimage.measure.EllipseModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.measure.fit.BaseModel</span></tt></p>
<p>Total least squares estimator for 2D ellipses.</p>
<p>The functional model of the ellipse is:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xt</span> <span class="o">=</span> <span class="n">xc</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">-</span> <span class="n">b</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">yt</span> <span class="o">=</span> <span class="n">yc</span> <span class="o">+</span> <span class="n">a</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">xt</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">yt</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">(xt,</span> <span class="pre">yt)</span></tt> is the closest point on the ellipse to <tt class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span></tt>. Thus
d is the shortest distance from the point to the ellipse.</p>
<p>This estimator minimizes the squared distances from all points to the
ellipse:</p>
<div class="highlight-python"><pre>min{ sum(d_i**2) } = min{ sum((x_i - xt)**2 + (y_i - yt)**2) }</pre>
</div>
<p>Thus you have <tt class="docutils literal"><span class="pre">2</span> <span class="pre">*</span> <span class="pre">N</span></tt> equations (x_i, y_i) for <tt class="docutils literal"><span class="pre">N</span> <span class="pre">+</span> <span class="pre">5</span></tt> unknowns (t_i,
xc, yc, a, b, theta), which gives you an effective redundancy of <tt class="docutils literal"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">5</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">_params</span></tt> attribute contains the parameters in the following order:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">xc</span><span class="p">,</span> <span class="n">yc</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">theta</span>
</pre></div>
</div>
<p>A minimum number of 5 points is required to solve for the parameters.</p>
<dl class="method">
<dt id="skimage.measure.EllipseModel.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.measure.EllipseModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.measure.EllipseModel.estimate">
<tt class="descname">estimate</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#skimage.measure.EllipseModel.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate circle model from data using total least squares.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>data</strong> : (N, 2) array</p>
<blockquote class="last">
<div><p>N points with <tt class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span></tt> coordinates, respectively.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.measure.EllipseModel.predict_xy">
<tt class="descname">predict_xy</tt><big>(</big><em>t</em>, <em>params=None</em><big>)</big><a class="headerlink" href="#skimage.measure.EllipseModel.predict_xy" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict x- and y-coordinates using the estimated model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>t</strong> : array</p>
<blockquote>
<div><p>Angles in circle in radians. Angles start to count from positive
x-axis to positive y-axis in a right-handed system.</p>
</div></blockquote>
<p><strong>params</strong> : (5, ) array, optional</p>
<blockquote>
<div><p>Optional custom parameter set.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>xy</strong> : (..., 2) array</p>
<blockquote class="last">
<div><p>Predicted x- and y-coordinates.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.measure.EllipseModel.residuals">
<tt class="descname">residuals</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#skimage.measure.EllipseModel.residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine residuals of data to model.</p>
<p>For each point the shortest distance to the ellipse is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>data</strong> : (N, 2) array</p>
<blockquote>
<div><p>N points with <tt class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span></tt> coordinates, respectively.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>residuals</strong> : (N, ) array</p>
<blockquote class="last">
<div><p>Residual for each data point.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="linemodel">
<h2><a class="reference internal" href="#skimage.measure.LineModel" title="skimage.measure.LineModel"><tt class="xref py py-class docutils literal"><span class="pre">LineModel</span></tt></a><a class="headerlink" href="#linemodel" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.measure.LineModel">
<em class="property">class </em><tt class="descclassname">skimage.measure.</tt><tt class="descname">LineModel</tt><a class="headerlink" href="#skimage.measure.LineModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.measure.fit.BaseModel</span></tt></p>
<p>Total least squares estimator for 2D lines.</p>
<p>Lines are parameterized using polar coordinates as functional model:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dist</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
</pre></div>
</div>
<p>This parameterization is able to model vertical lines in contrast to the
standard line model <tt class="docutils literal"><span class="pre">y</span> <span class="pre">=</span> <span class="pre">a*x</span> <span class="pre">+</span> <span class="pre">b</span></tt>.</p>
<p>This estimator minimizes the squared distances from all points to the
line:</p>
<div class="highlight-python"><pre>min{ sum((dist - x_i * cos(theta) + y_i * sin(theta))**2) }</pre>
</div>
<p>The <tt class="docutils literal"><span class="pre">_params</span></tt> attribute contains the parameters in the following order:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">dist</span><span class="p">,</span> <span class="n">theta</span>
</pre></div>
</div>
<p>A minimum number of 2 points is required to solve for the parameters.</p>
<dl class="method">
<dt id="skimage.measure.LineModel.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.measure.LineModel.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.measure.LineModel.estimate">
<tt class="descname">estimate</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#skimage.measure.LineModel.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate line model from data using total least squares.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>data</strong> : (N, 2) array</p>
<blockquote class="last">
<div><p>N points with <tt class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span></tt> coordinates, respectively.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.measure.LineModel.predict_x">
<tt class="descname">predict_x</tt><big>(</big><em>y</em>, <em>params=None</em><big>)</big><a class="headerlink" href="#skimage.measure.LineModel.predict_x" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict x-coordinates using the estimated model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>y</strong> : array</p>
<blockquote>
<div><p>y-coordinates.</p>
</div></blockquote>
<p><strong>params</strong> : (2, ) array, optional</p>
<blockquote>
<div><p>Optional custom parameter set.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>x</strong> : array</p>
<blockquote class="last">
<div><p>Predicted x-coordinates.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.measure.LineModel.predict_y">
<tt class="descname">predict_y</tt><big>(</big><em>x</em>, <em>params=None</em><big>)</big><a class="headerlink" href="#skimage.measure.LineModel.predict_y" title="Permalink to this definition">¶</a></dt>
<dd><p>Predict y-coordinates using the estimated model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>x</strong> : array</p>
<blockquote>
<div><p>x-coordinates.</p>
</div></blockquote>
<p><strong>params</strong> : (2, ) array, optional</p>
<blockquote>
<div><p>Optional custom parameter set.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>y</strong> : array</p>
<blockquote class="last">
<div><p>Predicted y-coordinates.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.measure.LineModel.residuals">
<tt class="descname">residuals</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#skimage.measure.LineModel.residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>Determine residuals of data to model.</p>
<p>For each point the shortest distance to the line is returned.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>data</strong> : (N, 2) array</p>
<blockquote>
<div><p>N points with <tt class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span></tt> coordinates, respectively.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>residuals</strong> : (N, ) array</p>
<blockquote class="last">
<div><p>Residual for each data point.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#skimage.measure.approximate_polygon" title="skimage.measure.approximate_polygon"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.measure.approximate_polygon</span></tt></a>(coords,&nbsp;...)</td>
<td>Approximate a polygonal chain with the specified tolerance.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.measure.find_contours" title="skimage.measure.find_contours"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.measure.find_contours</span></tt></a>(array,&nbsp;level)</td>
<td>Find iso-valued contours in a 2D array for a given level value.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.measure.perimeter" title="skimage.measure.perimeter"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.measure.perimeter</span></tt></a>(image[,&nbsp;neighbourhood])</td>
<td>Calculate total perimeter of all objects in binary image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.measure.ransac" title="skimage.measure.ransac"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.measure.ransac</span></tt></a>(data,&nbsp;model_class,&nbsp;...)</td>
<td>Fit a model to data with the RANSAC (random sample consensus) algorithm.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.measure.regionprops" title="skimage.measure.regionprops"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.measure.regionprops</span></tt></a>(label_image[,&nbsp;...])</td>
<td>Measure properties of labelled image regions.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.measure.structural_similarity" title="skimage.measure.structural_similarity"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.measure.structural_similarity</span></tt></a>(X,&nbsp;Y)</td>
<td>Compute the mean structural similarity index between two images.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.measure.subdivide_polygon" title="skimage.measure.subdivide_polygon"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.measure.subdivide_polygon</span></tt></a>(coords[,&nbsp;...])</td>
<td>Subdivision of polygonal curves using B-Splines.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="approximate-polygon">
<h2>approximate_polygon<a class="headerlink" href="#approximate-polygon" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.approximate_polygon">
<tt class="descclassname">skimage.measure.</tt><tt class="descname">approximate_polygon</tt><big>(</big><em>coords</em>, <em>tolerance</em><big>)</big><a class="headerlink" href="#skimage.measure.approximate_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Approximate a polygonal chain with the specified tolerance.</p>
<p>It is based on the Douglas-Peucker algorithm.</p>
<p>Note that the approximated polygon is always within the convex hull of the
original polygon.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>coords</strong> : (N, 2) array</p>
<blockquote>
<div><p>Coordinate array.</p>
</div></blockquote>
<p><strong>tolerance</strong> : float</p>
<blockquote>
<div><p>Maximum distance from original points of polygon to approximated
polygonal chain. If tolerance is 0, the original coordinate array
is returned.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>coords</strong> : (M, 2) array</p>
<blockquote class="last">
<div><p>Approximated polygonal chain where M &lt;= N.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r123" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[R123]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm">http://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="find-contours">
<h2>find_contours<a class="headerlink" href="#find-contours" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.find_contours">
<tt class="descclassname">skimage.measure.</tt><tt class="descname">find_contours</tt><big>(</big><em>array</em>, <em>level</em>, <em>fully_connected='low'</em>, <em>positive_orientation='low'</em><big>)</big><a class="headerlink" href="#skimage.measure.find_contours" title="Permalink to this definition">¶</a></dt>
<dd><p>Find iso-valued contours in a 2D array for a given level value.</p>
<p>Uses the &#8220;marching squares&#8221; method to compute a the iso-valued contours of
the input 2D array for a particular level value. Array values are linearly
interpolated to provide better precision for the output contours.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>array</strong> : 2D ndarray of double</p>
<blockquote>
<div><p>Input data in which to find contours.</p>
</div></blockquote>
<p><strong>level</strong> : float</p>
<blockquote>
<div><p>Value along which to find contours in the array.</p>
</div></blockquote>
<p><strong>fully_connected</strong> : str, {&#8216;low&#8217;, &#8216;high&#8217;}</p>
<blockquote>
<div><p>Indicates whether array elements below the given level value are to be
considered fully-connected (and hence elements above the value will
only be face connected), or vice-versa. (See notes below for details.)</p>
</div></blockquote>
<p><strong>positive_orientation</strong> : either &#8216;low&#8217; or &#8216;high&#8217;</p>
<blockquote>
<div><p>Indicates whether the output contours will produce positively-oriented
polygons around islands of low- or high-valued elements. If &#8216;low&#8217; then
contours will wind counter- clockwise around elements below the
iso-value. Alternately, this means that low-valued elements are always
on the left of the contour. (See below for details.)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>contours</strong> : list of (n,2)-ndarrays</p>
<blockquote class="last">
<div><p>Each contour is an ndarray of shape <tt class="docutils literal"><span class="pre">(n,</span> <span class="pre">2)</span></tt>,
consisting of n <tt class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span></tt> coordinates along the contour.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>The marching squares algorithm is a special case of the marching cubes
algorithm <a class="reference internal" href="#r124" id="id2">[R124]</a>.  A simple explanation is available here:</p>
<div class="highlight-python"><pre>http://www.essi.fr/~lingrand/MarchingCubes/algo.html</pre>
</div>
<p>There is a single ambiguous case in the marching squares algorithm: when
a given <tt class="docutils literal"><span class="pre">2</span> <span class="pre">x</span> <span class="pre">2</span></tt>-element square has two high-valued and two low-valued
elements, each pair diagonally adjacent. (Where high- and low-valued is
with respect to the contour value sought.) In this case, either the
high-valued elements can be &#8216;connected together&#8217; via a thin isthmus that
separates the low-valued elements, or vice-versa. When elements are
connected together across a diagonal, they are considered &#8216;fully
connected&#8217; (also known as &#8216;face+vertex-connected&#8217; or &#8216;8-connected&#8217;). Only
high-valued or low-valued elements can be fully-connected, the other set
will be considered as &#8216;face-connected&#8217; or &#8216;4-connected&#8217;. By default,
low-valued elements are considered fully-connected; this can be altered
with the &#8216;fully_connected&#8217; parameter.</p>
<p>Output contours are not guaranteed to be closed: contours which intersect
the array edge will be left open. All other contours will be closed. (The
closed-ness of a contours can be tested by checking whether the beginning
point is the same as the end point.)</p>
<p>Contours are oriented. By default, array values lower than the contour
value are to the left of the contour and values greater than the contour
value are to the right. This means that contours will wind
counter-clockwise (i.e. in &#8216;positive orientation&#8217;) around islands of
low-valued pixels. This behavior can be altered with the
&#8216;positive_orientation&#8217; parameter.</p>
<p>The order of the contours in the output list is determined by the position
of the smallest <tt class="docutils literal"><span class="pre">x,y</span></tt> (in lexicographical order) coordinate in the
contour.  This is a side-effect of how the input array is traversed, but
can be relied upon.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Array coordinates/values are assumed to refer to the <em>center</em> of the
array element. Take a simple example input: <tt class="docutils literal"><span class="pre">[0,</span> <span class="pre">1]</span></tt>. The interpolated
position of 0.5 in this array is midway between the 0-element (at
<tt class="docutils literal"><span class="pre">x=0</span></tt>) and the 1-element (at <tt class="docutils literal"><span class="pre">x=1</span></tt>), and thus would fall at
<tt class="docutils literal"><span class="pre">x=0.5</span></tt>.</p>
</div>
<p>This means that to find reasonable contours, it is best to find contours
midway between the expected &#8220;light&#8221; and &#8220;dark&#8221; values. In particular,
given a binarized array, <em>do not</em> choose to find contours at the low or
high value of the array. This will often yield degenerate contours,
especially around structures that are a single array element wide. Instead
choose a middle value, as above.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r124" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R124]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id3">2</a>)</em> Lorensen, William and Harvey E. Cline. Marching Cubes: A High
Resolution 3D Surface Construction Algorithm. Computer Graphics
(SIGGRAPH 87 Proceedings) 21(4) July 1987, p. 163-170).</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([[ 1.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.],</span>
<span class="go">       [ 0.,  0.,  0.]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">find_contours</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="go">[array([[ 0. ,  0.5],</span>
<span class="go">       [ 0.5,  0. ]])]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="perimeter">
<h2>perimeter<a class="headerlink" href="#perimeter" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.perimeter">
<tt class="descclassname">skimage.measure.</tt><tt class="descname">perimeter</tt><big>(</big><em>image</em>, <em>neighbourhood=4</em><big>)</big><a class="headerlink" href="#skimage.measure.perimeter" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate total perimeter of all objects in binary image.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : array</p>
<blockquote>
<div><p>binary image</p>
</div></blockquote>
<p><strong>neighbourhood</strong> : 4 or 8, optional</p>
<blockquote>
<div><p>neighbourhood connectivity for border pixel determination, default 4</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>perimeter</strong> : float</p>
<blockquote class="last">
<div><p>total perimeter of all objects in binary image</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r125" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[R125]</a></td><td>K. Benkrid, D. Crookes. Design and FPGA Implementation of
a Perimeter Estimator. The Queen&#8217;s University of Belfast.
<a class="reference external" href="http://www.cs.qub.ac.uk/~d.crookes/webpubs/papers/perimeter.doc">http://www.cs.qub.ac.uk/~d.crookes/webpubs/papers/perimeter.doc</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="ransac">
<h2>ransac<a class="headerlink" href="#ransac" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.ransac">
<tt class="descclassname">skimage.measure.</tt><tt class="descname">ransac</tt><big>(</big><em>data</em>, <em>model_class</em>, <em>min_samples</em>, <em>residual_threshold</em>, <em>is_data_valid=None</em>, <em>is_model_valid=None</em>, <em>max_trials=100</em>, <em>stop_sample_num=inf</em>, <em>stop_residuals_sum=0</em><big>)</big><a class="headerlink" href="#skimage.measure.ransac" title="Permalink to this definition">¶</a></dt>
<dd><p>Fit a model to data with the RANSAC (random sample consensus) algorithm.</p>
<p>RANSAC is an iterative algorithm for the robust estimation of parameters
from a subset of inliers from the complete data set. Each iteration
performs the following tasks:</p>
<ol class="arabic simple">
<li>Select <cite>min_samples</cite> random samples from the original data and check
whether the set of data is valid (see <cite>is_data_valid</cite>).</li>
<li>Estimate a model to the random subset
(<cite>model_cls.estimate(*data[random_subset]</cite>) and check whether the
estimated model is valid (see <cite>is_model_valid</cite>).</li>
<li>Classify all data as inliers or outliers by calculating the residuals
to the estimated model (<cite>model_cls.residuals(*data)</cite>) - all data samples
with residuals smaller than the <cite>residual_threshold</cite> are considered as
inliers.</li>
<li>Save estimated model as best model if number of inlier samples is
maximal. In case the current estimated model has the same number of
inliers, it is only considered as the best model if it has less sum of
residuals.</li>
</ol>
<p>These steps are performed either a maximum number of times or until one of
the special stop criteria are met. The final model is estimated using all
inlier samples of the previously determined best model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>data</strong> : [list, tuple of] (N, D) array</p>
<blockquote>
<div><p>Data set to which the model is fitted, where N is the number of data
points and D the dimensionality of the data.
If the model class requires multiple input data arrays (e.g. source and
destination coordinates of  <tt class="docutils literal"><span class="pre">skimage.transform.AffineTransform</span></tt>),
they can be optionally passed as tuple or list. Note, that in this case
the functions <tt class="docutils literal"><span class="pre">estimate(*data)</span></tt>, <tt class="docutils literal"><span class="pre">residuals(*data)</span></tt>,
<tt class="docutils literal"><span class="pre">is_model_valid(model,</span> <span class="pre">*random_data)</span></tt> and
<tt class="docutils literal"><span class="pre">is_data_valid(*random_data)</span></tt> must all take each data array as
separate arguments.</p>
</div></blockquote>
<p><strong>model_class</strong> : object</p>
<blockquote>
<div><p>Object with the following object methods:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">estimate(*data)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">residuals(*data)</span></tt></li>
</ul>
</div></blockquote>
</div></blockquote>
<p><strong>min_samples</strong> : int</p>
<blockquote>
<div><p>The minimum number of data points to fit a model to.</p>
</div></blockquote>
<p><strong>residual_threshold</strong> : float</p>
<blockquote>
<div><p>Maximum distance for a data point to be classified as an inlier.</p>
</div></blockquote>
<p><strong>is_data_valid</strong> : function, optional</p>
<blockquote>
<div><p>This function is called with the randomly selected data before the
model is fitted to it: <cite>is_data_valid(*random_data)</cite>.</p>
</div></blockquote>
<p><strong>is_model_valid</strong> : function, optional</p>
<blockquote>
<div><p>This function is called with the estimated model and the randomly
selected data: <cite>is_model_valid(model, *random_data)</cite>, .</p>
</div></blockquote>
<p><strong>max_trials</strong> : int, optional</p>
<blockquote>
<div><p>Maximum number of iterations for random sample selection.</p>
</div></blockquote>
<p><strong>stop_sample_num</strong> : int, optional</p>
<blockquote>
<div><p>Stop iteration if at least this number of inliers are found.</p>
</div></blockquote>
<p><strong>stop_residuals_sum</strong> : float, optional</p>
<blockquote>
<div><p>Stop iteration if sum of residuals is less equal than this threshold.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>model</strong> : object</p>
<blockquote>
<div><p>Best model with largest consensus set.</p>
</div></blockquote>
<p><strong>inliers</strong> : (N, ) array</p>
<blockquote class="last">
<div><p>Boolean mask of inliers classified as <tt class="docutils literal"><span class="pre">True</span></tt>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r126" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[R126]</a></td><td>&#8220;RANSAC&#8221;, Wikipedia, <a class="reference external" href="http://en.wikipedia.org/wiki/RANSAC">http://en.wikipedia.org/wiki/RANSAC</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Generate ellipse data without tilt and add noise:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xc</span> <span class="o">=</span> <span class="mi">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">yc</span> <span class="o">=</span> <span class="mi">30</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">xc</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">yc</span> <span class="o">+</span> <span class="n">b</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">1234</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>
</div>
<p>Add some faulty data:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">110</span><span class="p">,</span> <span class="mi">120</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">120</span><span class="p">,</span> <span class="mi">130</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">140</span><span class="p">,</span> <span class="mi">130</span><span class="p">)</span>
</pre></div>
</div>
<p>Estimate ellipse model using all available data:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">model</span> <span class="o">=</span> <span class="n">EllipseModel</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="o">.</span><span class="n">_params</span>
<span class="go">array([  4.85808595e+02,   4.51492793e+02,   1.15018491e+03,</span>
<span class="go">         5.52428289e+00,   7.32420126e-01])</span>
</pre></div>
</div>
<p>Estimate ellipse model using RANSAC:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ransac_model</span><span class="p">,</span> <span class="n">inliers</span> <span class="o">=</span> <span class="n">ransac</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">EllipseModel</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">max_trials</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># ransac_model._params, inliers</span>
</pre></div>
</div>
<p>Should give the correct result estimated without the faulty data:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span> <span class="mf">20.12762373</span><span class="p">,</span> <span class="mf">29.73563061</span><span class="p">,</span> <span class="mf">4.81499637</span><span class="p">,</span> <span class="mf">10.4743584</span><span class="p">,</span> <span class="mf">0.05217117</span><span class="p">]</span>
<span class="p">[</span> <span class="mi">4</span><span class="p">,</span>  <span class="mi">5</span><span class="p">,</span>  <span class="mi">6</span><span class="p">,</span>  <span class="mi">7</span><span class="p">,</span>  <span class="mi">8</span><span class="p">,</span>  <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span>
 <span class="mi">21</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">34</span><span class="p">,</span> <span class="mi">35</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span>
 <span class="mi">38</span><span class="p">,</span> <span class="mi">39</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">43</span><span class="p">,</span> <span class="mi">44</span><span class="p">,</span> <span class="mi">45</span><span class="p">,</span> <span class="mi">46</span><span class="p">,</span> <span class="mi">47</span><span class="p">,</span> <span class="mi">48</span><span class="p">,</span> <span class="mi">49</span><span class="p">]</span>
</pre></div>
</div>
<p>Robustly estimate geometric transformation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">SimilarityTransform</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">src</span> <span class="o">=</span> <span class="mi">100</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">50</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model0</span> <span class="o">=</span> <span class="n">SimilarityTransform</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>                             <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span> <span class="o">=</span> <span class="n">model0</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model</span><span class="p">,</span> <span class="n">inliers</span> <span class="o">=</span> <span class="n">ransac</span><span class="p">((</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">),</span> <span class="n">SimilarityTransform</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inliers</span>
<span class="go">array([ 3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,</span>
<span class="go">   20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,</span>
<span class="go">   37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="regionprops">
<h2>regionprops<a class="headerlink" href="#regionprops" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.regionprops">
<tt class="descclassname">skimage.measure.</tt><tt class="descname">regionprops</tt><big>(</big><em>label_image, properties=['Area', 'Centroid'], intensity_image=None</em><big>)</big><a class="headerlink" href="#skimage.measure.regionprops" title="Permalink to this definition">¶</a></dt>
<dd><p>Measure properties of labelled image regions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>label_image</strong> : (N, M) ndarray</p>
<blockquote>
<div><p>Labelled input image.</p>
</div></blockquote>
<p><strong>properties</strong> : {&#8216;all&#8217;, list}</p>
<blockquote>
<div><p>Shape measurements to be determined for each labelled image region.
Default is <cite>[&#8216;Area&#8217;, &#8216;Centroid&#8217;]</cite>. The following properties can be
determined:</p>
<ul>
<li><dl class="first docutils">
<dt>Area <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of pixels of region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>BoundingBox <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">Bounding box <cite>(min_row, min_col, max_row, max_col)</cite></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>CentralMoments <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) ndarray</span></dt>
<dd><p class="first">Central moments (translation invariant) up to 3rd order.</p>
<blockquote>
<div><p>mu_ji = sum{ array(x, y) * (x - x_c)^j * (y - y_c)^i }</p>
</div></blockquote>
<p class="last">where the sum is over the <cite>x</cite>, <cite>y</cite> coordinates of the region,
and <cite>x_c</cite> and <cite>y_c</cite> are the coordinates of the region&#8217;s centroid.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Centroid <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Centroid coordinate tuple <cite>(row, col)</cite>.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ConvexArea <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of pixels of convex hull image.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>ConvexImage <span class="classifier-delimiter">:</span> <span class="classifier">(H, J) ndarray</span></dt>
<dd><p class="first last">Binary convex hull image which has the same size as bounding box.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Coordinates <span class="classifier-delimiter">:</span> <span class="classifier">(N, 2) ndarray</span></dt>
<dd><p class="first last">Coordinate list <cite>(row, col)</cite> of the region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Eccentricity <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Eccentricity of the ellipse that has the same second-moments as the
region. The eccentricity is the ratio of the distance between its
minor and major axis length. The value is between 0 and 1.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>EquivDiameter <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The diameter of a circle with the same area as the region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>EulerNumber <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Euler number of region. Computed as number of objects (= 1)
subtracted by number of holes (8-connectivity).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Extent <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Ratio of pixels in the region to pixels in the total bounding box.
Computed as <cite>Area / (rows*cols)</cite></p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>FilledArea <span class="classifier-delimiter">:</span> <span class="classifier">int</span></dt>
<dd><p class="first last">Number of pixels of filled region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>FilledImage <span class="classifier-delimiter">:</span> <span class="classifier">(H, J) ndarray</span></dt>
<dd><p class="first last">Binary region image with filled holes which has the same size as
bounding box.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>HuMoments <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">Hu moments (translation, scale and rotation invariant).</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Image <span class="classifier-delimiter">:</span> <span class="classifier">(H, J) ndarray</span></dt>
<dd><p class="first last">Sliced binary region image which has the same size as bounding box.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>MajorAxisLength <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The length of the major axis of the ellipse that has the same
normalized second central moments as the region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>MaxIntensity: float</dt>
<dd><p class="first last">Value with the greatest intensity in the region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>MeanIntensity: float</dt>
<dd><p class="first last">Value with the mean intensity in the region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>MinIntensity: float</dt>
<dd><p class="first last">Value with the least intensity in the region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>MinorAxisLength <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">The length of the minor axis of the ellipse that has the same
normalized second central moments as the region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Moments <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) ndarray</span></dt>
<dd><p class="first">Spatial moments up to 3rd order.</p>
<blockquote>
<div><p>m_ji = sum{ array(x, y) * x^j * y^i }</p>
</div></blockquote>
<p class="last">where the sum is over the <cite>x</cite>, <cite>y</cite> coordinates of the region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>NormalizedMoments <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) ndarray</span></dt>
<dd><p class="first">Normalized moments (translation and scale invariant) up to 3rd
order.</p>
<blockquote>
<div><p>nu_ji = mu_ji / m_00^[(i+j)/2 + 1]</p>
</div></blockquote>
<p class="last">where <cite>m_00</cite> is the zeroth spatial moment.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Orientation <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Angle between the X-axis and the major axis of the ellipse that has
the same second-moments as the region. Ranging from <cite>-pi/2</cite> to
<cite>pi/2</cite> in counter-clockwise direction.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Perimeter <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Perimeter of object which approximates the contour as a line
through the centers of border pixels using a 4-connectivity.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Solidity <span class="classifier-delimiter">:</span> <span class="classifier">float</span></dt>
<dd><p class="first last">Ratio of pixels in the region to pixels of the convex hull image.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>WeightedCentralMoments <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) ndarray</span></dt>
<dd><p class="first">Central moments (translation invariant) of intensity image up to
3rd order.</p>
<blockquote>
<div><p>wmu_ji = sum{ array(x, y) * (x - x_c)^j * (y - y_c)^i }</p>
</div></blockquote>
<p class="last">where the sum is over the <cite>x</cite>, <cite>y</cite> coordinates of the region,
and <cite>x_c</cite> and <cite>y_c</cite> are the coordinates of the region&#8217;s centroid.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>WeightedCentroid <span class="classifier-delimiter">:</span> <span class="classifier">array</span></dt>
<dd><p class="first last">Centroid coordinate tuple <cite>(row, col)</cite> weighted with intensity
image.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>WeightedHuMoments <span class="classifier-delimiter">:</span> <span class="classifier">tuple</span></dt>
<dd><p class="first last">Hu moments (translation, scale and rotation invariant) of intensity
image.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>WeightedMoments <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) ndarray</span></dt>
<dd><p class="first">Spatial moments of intensity image up to 3rd order.</p>
<blockquote>
<div><p>wm_ji = sum{ array(x, y) * x^j * y^i }</p>
</div></blockquote>
<p class="last">where the sum is over the <cite>x</cite>, <cite>y</cite> coordinates of the region.</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>WeightedNormalizedMoments <span class="classifier-delimiter">:</span> <span class="classifier">(3, 3) ndarray</span></dt>
<dd><p class="first">Normalized moments (translation and scale invariant) of intensity
image up to 3rd order.</p>
<blockquote>
<div><p>wnu_ji = wmu_ji / wm_00^[(i+j)/2 + 1]</p>
</div></blockquote>
<p class="last">where <cite>wm_00</cite> is the zeroth spatial moment (intensity-weighted
area).</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<p><strong>intensity_image</strong> : (N, M) ndarray, optional</p>
<blockquote>
<div><p>Intensity image with same size as labelled image. Default is None.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>properties</strong> : list of dicts</p>
<blockquote class="last">
<div><p>List containing a property dict for each region. The property dicts
contain all the specified properties plus a &#8216;Label&#8217; field.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r127" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[R127]</a></td><td>Wilhelm Burger, Mark Burge. Principles of Digital Image Processing:
Core Algorithms. Springer-Verlag, London, 2009.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r128" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[R128]</a></td><td>B. Jähne. Digital Image Processing. Springer-Verlag,
Berlin-Heidelberg, 6. edition, 2005.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r129" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[R129]</a></td><td>T. H. Reiss. Recognizing Planar Objects Using Invariant Image
Features, from Lecture notes in computer science, p. 676. Springer,
Berlin, 1993.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="r130" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[R130]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Image_moment">http://en.wikipedia.org/wiki/Image_moment</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.data</span> <span class="kn">import</span> <span class="n">coins</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">label</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">coins</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">110</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">label_img</span> <span class="o">=</span> <span class="n">label</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span> <span class="o">=</span> <span class="n">regionprops</span><span class="p">(</span><span class="n">label_img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">props</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">&#39;Centroid&#39;</span><span class="p">]</span> <span class="c"># centroid of first labelled object</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="structural-similarity">
<h2>structural_similarity<a class="headerlink" href="#structural-similarity" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.structural_similarity">
<tt class="descclassname">skimage.measure.</tt><tt class="descname">structural_similarity</tt><big>(</big><em>X</em>, <em>Y</em>, <em>win_size=7</em>, <em>gradient=False</em>, <em>dynamic_range=None</em><big>)</big><a class="headerlink" href="#skimage.measure.structural_similarity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mean structural similarity index between two images.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>X, Y</strong> : (N,N) ndarray</p>
<blockquote>
<div><p>Images.</p>
</div></blockquote>
<p><strong>win_size</strong> : int</p>
<blockquote>
<div><p>The side-length of the sliding window used in comparison.  Must
be an odd value.</p>
</div></blockquote>
<p><strong>gradient</strong> : bool</p>
<blockquote>
<div><p>If True, also return the gradient.</p>
</div></blockquote>
<p><strong>dynamic_range</strong> : int</p>
<blockquote>
<div><p>Dynamic range of the input image (distance between minimum and
maximum possible values).  By default, this is estimated from
the image data-type.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>s</strong> : float</p>
<blockquote>
<div><p>Strucutural similarity.</p>
</div></blockquote>
<p><strong>grad</strong> : (N * N,) ndarray</p>
<blockquote class="last">
<div><p>Gradient of the structural similarity index between X and Y.
This is only returned if <cite>gradient</cite> is set to True.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r131" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[R131]</a></td><td>Wang, Z., Bovik, A. C., Sheikh, H. R., &amp; Simoncelli, E. P.
(2004). Image quality assessment: From error visibility to
structural similarity. IEEE Transactions on Image Processing,
13, 600-612.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="subdivide-polygon">
<h2>subdivide_polygon<a class="headerlink" href="#subdivide-polygon" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.measure.subdivide_polygon">
<tt class="descclassname">skimage.measure.</tt><tt class="descname">subdivide_polygon</tt><big>(</big><em>coords</em>, <em>degree=2</em>, <em>preserve_ends=False</em><big>)</big><a class="headerlink" href="#skimage.measure.subdivide_polygon" title="Permalink to this definition">¶</a></dt>
<dd><p>Subdivision of polygonal curves using B-Splines.</p>
<p>Note that the resulting curve is always within the convex hull of the
original polygon. Circular polygons stay closed after subdivision.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>coords</strong> : (N, 2) array</p>
<blockquote>
<div><p>Coordinate array.</p>
</div></blockquote>
<p><strong>degree</strong> : {1, 2, 3, 4, 5, 6, 7}, optional</p>
<blockquote>
<div><p>Degree of B-Spline. Default is 2.</p>
</div></blockquote>
<p><strong>preserve_ends</strong> : bool, optional</p>
<blockquote>
<div><p>Preserve first and last coordinate of non-circular polygon. Default is
False.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>coords</strong> : (M, 2) array</p>
<blockquote class="last">
<div><p>Subdivided coordinate array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r132" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[R132]</a></td><td><a class="reference external" href="http://mrl.nyu.edu/publications/subdiv-course2000/coursenotes00.pdf">http://mrl.nyu.edu/publications/subdiv-course2000/coursenotes00.pdf</a></td></tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


        </div>
        <div class="span3"><h4 class="sidebar-box-heading">Navigation</h4>
<div class="well sidebar-box">
    <ul class="nav nav-list">
        <li><a href="../index.html">Documentation Home</a></li>
    </ul>
</div>
        <h4 class="sidebar-box-heading">Contents</h4>
        <div class="well sidebar-box toc">
            <ul class="nav nav-list">
<li><a class="reference internal" href="#">Module: <tt class="docutils literal"><span class="pre">measure</span></tt></a><ul class="nav nav-list">
<li><a class="reference internal" href="#circlemodel"><tt class="docutils literal"><span class="pre">CircleModel</span></tt></a></li>
<li><a class="reference internal" href="#ellipsemodel"><tt class="docutils literal"><span class="pre">EllipseModel</span></tt></a></li>
<li><a class="reference internal" href="#linemodel"><tt class="docutils literal"><span class="pre">LineModel</span></tt></a></li>
<li><a class="reference internal" href="#approximate-polygon">approximate_polygon</a></li>
<li><a class="reference internal" href="#find-contours">find_contours</a></li>
<li><a class="reference internal" href="#perimeter">perimeter</a></li>
<li><a class="reference internal" href="#ransac">ransac</a></li>
<li><a class="reference internal" href="#regionprops">regionprops</a></li>
<li><a class="reference internal" href="#structural-similarity">structural_similarity</a></li>
<li><a class="reference internal" href="#subdivide-polygon">subdivide_polygon</a></li>
</ul>
</li>
</ul>

        </div>

<h4 class="sidebar-box-heading">Versions</h4>
<div class="well sidebar-box">
    <ul class="nav nav-list">
        <script src="../_static/docversions.js"></script>
        <script type="text/javascript">
            insert_version_links();
        </script>
    </ul>
</div>
        </div>
    </div>
    <div class="well footer">
        <small>
            &copy; Copyright the scikit-image development team.
            Created using <a href="http://twitter.github.com/bootstrap/">Bootstrap</a> and <a href="http://sphinx.pocoo.org/">Sphinx</a>.
        </small>
    </div>
</body>
</html>