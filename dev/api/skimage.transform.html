

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Module: transform &mdash; skimage v0.7dev docs</title>
    <link rel="stylesheet" href="../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.7dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/docversions.js"></script>
    <link rel="top" title="skimage v0.7dev docs" href="../index.html" /> 
  </head>
  <body>
    <div class="header-wrapper">
      <div class="header">
          <div class="logo"><a href="http://scikits-image.org">
            <img class="logo" src="../_static/scikits_image_logo_small.png" alt="Logo"/>
          </a></div>
       
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
             
            
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper"> 

  
    <h3>Navigation</h3>
    <p>
    <a href="../index.html">Documentation Home</a>
    </p>
    <p>&nbsp;</p>
  
    <h3>Contents</h3>
    <ul>
<li><a class="reference internal" href="#">Module: <tt class="docutils literal"><span class="pre">transform</span></tt></a><ul>
<li><a class="reference internal" href="#affinetransform"><tt class="docutils literal"><span class="pre">AffineTransform</span></tt></a><ul>
</ul>
</li>
<li><a class="reference internal" href="#polynomialtransform"><tt class="docutils literal"><span class="pre">PolynomialTransform</span></tt></a><ul>
</ul>
</li>
<li><a class="reference internal" href="#projectivetransform"><tt class="docutils literal"><span class="pre">ProjectiveTransform</span></tt></a><ul>
</ul>
</li>
<li><a class="reference internal" href="#similaritytransform"><tt class="docutils literal"><span class="pre">SimilarityTransform</span></tt></a><ul>
</ul>
</li>
<li><a class="reference internal" href="#estimate-transform">estimate_transform</a></li>
<li><a class="reference internal" href="#fast-homography">fast_homography</a></li>
<li><a class="reference internal" href="#frt2">frt2</a></li>
<li><a class="reference internal" href="#homography">homography</a></li>
<li><a class="reference internal" href="#hough">hough</a></li>
<li><a class="reference internal" href="#ifrt2">ifrt2</a></li>
<li><a class="reference internal" href="#integral-image">integral_image</a></li>
<li><a class="reference internal" href="#integrate">integrate</a></li>
<li><a class="reference internal" href="#iradon">iradon</a></li>
<li><a class="reference internal" href="#probabilistic-hough">probabilistic_hough</a></li>
<li><a class="reference internal" href="#radon">radon</a></li>
<li><a class="reference internal" href="#swirl">swirl</a></li>
<li><a class="reference internal" href="#warp">warp</a></li>
</ul>
</li>
</ul>




  <h3>Version</h3>

    <script type="text/javascript">
      insert_version_links();
    </script>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
        
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-transform">
<h1>Module: <tt class="xref py py-mod docutils literal"><span class="pre">transform</span></tt><a class="headerlink" href="#module-transform" title="Permalink to this headline">¶</a></h1>
<p>Inheritance diagram for <tt class="docutils literal"><span class="pre">skimage.transform</span></tt>:</p>
<span class="target" id="module-skimage.transform"></span><div class="section" id="affinetransform">
<h2><a class="reference internal" href="#skimage.transform.AffineTransform" title="skimage.transform.AffineTransform"><tt class="xref py py-class docutils literal"><span class="pre">AffineTransform</span></tt></a><a class="headerlink" href="#affinetransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.AffineTransform">
<em class="property">class </em><tt class="descclassname">skimage.transform.</tt><tt class="descname">AffineTransform</tt><big>(</big><em>matrix=None</em>, <em>scale=None</em>, <em>rotation=None</em>, <em>shear=None</em>, <em>translation=None</em><big>)</big><a class="headerlink" href="#skimage.transform.AffineTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.transform._geometric.ProjectiveTransform</span></tt></p>
<p>2D affine transformation of the form:</p>
<div class="highlight-python"><pre>X = a0*x + a1*y + a2 =
  = sx*x*cos(rotation) - sy*y*sin(rotation + shear) + a2

Y = b0*x + b1*y + b2 =
  = sx*x*sin(rotation) + sy*y*cos(rotation + shear) + b2</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">sx</span></tt> and <tt class="docutils literal"><span class="pre">sy</span></tt> are zoom factors in the x and y directions,
and the homogeneous transformation matrix is:</p>
<div class="highlight-python"><pre>[[a0  a1  a2]
 [b0  b1  b2]
 [0   0    1]]</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>matrix</strong> : (3, 3) array, optional</p>
<blockquote>
<div><p>Homogeneous transformation matrix.</p>
</div></blockquote>
<p><strong>scale</strong> : (sx, sy) as array, list or tuple, optional</p>
<blockquote>
<div><p>scale factors</p>
</div></blockquote>
<p><strong>rotation</strong> : float, optional</p>
<blockquote>
<div><p>rotation angle in counter-clockwise direction as radians</p>
</div></blockquote>
<p><strong>shear</strong> : float, optional</p>
<blockquote>
<div><p>shear angle in counter-clockwise direction as radians</p>
</div></blockquote>
<p><strong>translation</strong> : (tx, ty) as array, list or tuple, optional</p>
<blockquote class="last">
<div><p>translation parameters</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr><td><a class="reference internal" href="#skimage.transform.AffineTransform.estimate" title="skimage.transform.AffineTransform.estimate"><tt class="xref py py-obj docutils literal"><span class="pre">estimate</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#skimage.transform.AffineTransform.inverse" title="skimage.transform.AffineTransform.inverse"><tt class="xref py py-obj docutils literal"><span class="pre">inverse</span></tt></a></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.transform.AffineTransform.__init__">
<tt class="descname">__init__</tt><big>(</big><em>matrix=None</em>, <em>scale=None</em>, <em>rotation=None</em>, <em>shear=None</em>, <em>translation=None</em><big>)</big><a class="headerlink" href="#skimage.transform.AffineTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.transform.AffineTransform.estimate">
<tt class="descname">estimate</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#skimage.transform.AffineTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the transformation matrix with the explicit transformation
parameters.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="p">(</span><span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mi">0</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">X</span>
<span class="mi">0</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">Y</span>
</pre></div>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-python"><pre>A   = [[x y 1 0 0 0 -x*X -y*X -X]
       [0 0 0 x y 1 -x*Y -y*Y -Y]
        ...
        ...
      ]
x.T = [a0 a1 a2 b0 b1 b2 c0 c1 c3]</pre>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<p>In case of the affine transformation the coefficients c0 and c1 are 0.
Thus the system of equations is:</p>
<div class="highlight-python"><pre>A   = [[x y 1 0 0 0 -X]
       [0 0 0 x y 1 -Y]
        ...
        ...
      ]
x.T = [a0 a1 a2 b0 b1 b2 c3]</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>src</strong> : (N, 2) array</p>
<blockquote>
<div><p>source coordinates</p>
</div></blockquote>
<p><strong>dst</strong> : (N, 2) array</p>
<blockquote class="last">
<div><p>destination coordinates</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.AffineTransform.inverse">
<tt class="descname">inverse</tt><big>(</big><em>coords</em><big>)</big><a class="headerlink" href="#skimage.transform.AffineTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.AffineTransform.rotation">
<tt class="descname">rotation</tt><a class="headerlink" href="#skimage.transform.AffineTransform.rotation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.AffineTransform.scale">
<tt class="descname">scale</tt><a class="headerlink" href="#skimage.transform.AffineTransform.scale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.AffineTransform.shear">
<tt class="descname">shear</tt><a class="headerlink" href="#skimage.transform.AffineTransform.shear" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.AffineTransform.translation">
<tt class="descname">translation</tt><a class="headerlink" href="#skimage.transform.AffineTransform.translation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="polynomialtransform">
<h2><a class="reference internal" href="#skimage.transform.PolynomialTransform" title="skimage.transform.PolynomialTransform"><tt class="xref py py-class docutils literal"><span class="pre">PolynomialTransform</span></tt></a><a class="headerlink" href="#polynomialtransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.PolynomialTransform">
<em class="property">class </em><tt class="descclassname">skimage.transform.</tt><tt class="descname">PolynomialTransform</tt><big>(</big><em>params=None</em><big>)</big><a class="headerlink" href="#skimage.transform.PolynomialTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.transform._geometric.GeometricTransform</span></tt></p>
<p>2D transformation of the form:</p>
<div class="highlight-python"><pre>X = sum[j=0:order]( sum[i=0:j]( a_ji * x**(j - i) * y**i ))
Y = sum[j=0:order]( sum[i=0:j]( b_ji * x**(j - i) * y**i ))</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>params</strong> : (2, N) array, optional</p>
<blockquote class="last">
<div><p>Polynomial coefficients where <cite>N * 2 = (order + 1) * (order + 2)</cite>. So,
a_ji is defined in <cite>params[0, :]</cite> and b_ji in <cite>params[1, :]</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr><td><a class="reference internal" href="#skimage.transform.PolynomialTransform.estimate" title="skimage.transform.PolynomialTransform.estimate"><tt class="xref py py-obj docutils literal"><span class="pre">estimate</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#skimage.transform.PolynomialTransform.inverse" title="skimage.transform.PolynomialTransform.inverse"><tt class="xref py py-obj docutils literal"><span class="pre">inverse</span></tt></a></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.transform.PolynomialTransform.__init__">
<tt class="descname">__init__</tt><big>(</big><em>params=None</em><big>)</big><a class="headerlink" href="#skimage.transform.PolynomialTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.transform.PolynomialTransform.estimate">
<tt class="descname">estimate</tt><big>(</big><em>src</em>, <em>dst</em>, <em>order</em><big>)</big><a class="headerlink" href="#skimage.transform.PolynomialTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the transformation matrix with the explicit transformation
parameters.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-python"><pre>X = sum[j=0:order]( sum[i=0:j]( a_ji * x**(j - i) * y**i ))
Y = sum[j=0:order]( sum[i=0:j]( b_ji * x**(j - i) * y**i ))</pre>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-python"><pre>0 = sum[j=0:order]( sum[i=0:j]( a_ji * x**(j - i) * y**i )) - X
0 = sum[j=0:order]( sum[i=0:j]( b_ji * x**(j - i) * y**i )) - Y</pre>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-python"><pre>A   = [[1 x y x**2 x*y y**2 ... 0 ...             0 -X]
       [0 ...                 0 1 x y x**2 x*y y**2 -Y]
        ...
        ...
      ]
x.T = [a00 a10 a11 a20 a21 a22 ... ann
       b00 b10 b11 b20 b21 b22 ... bnn c3]</pre>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>src</strong> : (N, 2) array</p>
<blockquote>
<div><p>source coordinates</p>
</div></blockquote>
<p><strong>dst</strong> : (N, 2) array</p>
<blockquote>
<div><p>destination coordinates</p>
</div></blockquote>
<p><strong>order</strong> : int</p>
<blockquote class="last">
<div><p>polynomial order (number of coefficients is order + 1)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.PolynomialTransform.inverse">
<tt class="descname">inverse</tt><big>(</big><em>coords</em><big>)</big><a class="headerlink" href="#skimage.transform.PolynomialTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="projectivetransform">
<h2><a class="reference internal" href="#skimage.transform.ProjectiveTransform" title="skimage.transform.ProjectiveTransform"><tt class="xref py py-class docutils literal"><span class="pre">ProjectiveTransform</span></tt></a><a class="headerlink" href="#projectivetransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.ProjectiveTransform">
<em class="property">class </em><tt class="descclassname">skimage.transform.</tt><tt class="descname">ProjectiveTransform</tt><big>(</big><em>matrix=None</em><big>)</big><a class="headerlink" href="#skimage.transform.ProjectiveTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.transform._geometric.GeometricTransform</span></tt></p>
<p>Matrix transformation.</p>
<p>Apply a projective transformation (homography) on coordinates.</p>
<p>For each homogeneous coordinate <img class="math" src="../_images/math/8800e6ed331cf15ba182031609babfac06216a77.png" alt="\mathbf{x} = [x, y, 1]^T"/>, its
target position is calculated by multiplying with the given matrix,
<img class="math" src="../_images/math/b1902d279ba37d60bdce4e0e987b7cd19d48974e.png" alt="H"/>, to give <img class="math" src="../_images/math/42a03cd1c073037bd9cd9e953d4ab607bb70d4c5.png" alt="H \mathbf{x}"/>:</p>
<div class="highlight-python"><pre>[[a0 a1 a2]
 [b0 b1 b2]
 [c0 c1 1 ]].</pre>
</div>
<p>E.g., to rotate by theta degrees clockwise, the matrix should be:</p>
<div class="highlight-python"><pre>[[cos(theta) -sin(theta) 0]
 [sin(theta)  cos(theta) 0]
 [0            0         1]]</pre>
</div>
<p>or, to translate x by 10 and y by 20:</p>
<div class="highlight-python"><pre>[[1 0 10]
 [0 1 20]
 [0 0 1 ]].</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>matrix</strong> : (3, 3) array, optional</p>
<blockquote class="last">
<div><p>Homogeneous transformation matrix.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr><td><a class="reference internal" href="#skimage.transform.ProjectiveTransform.estimate" title="skimage.transform.ProjectiveTransform.estimate"><tt class="xref py py-obj docutils literal"><span class="pre">estimate</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#skimage.transform.ProjectiveTransform.inverse" title="skimage.transform.ProjectiveTransform.inverse"><tt class="xref py py-obj docutils literal"><span class="pre">inverse</span></tt></a></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.transform.ProjectiveTransform.__init__">
<tt class="descname">__init__</tt><big>(</big><em>matrix=None</em><big>)</big><a class="headerlink" href="#skimage.transform.ProjectiveTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.transform.ProjectiveTransform.estimate">
<tt class="descname">estimate</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#skimage.transform.ProjectiveTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the transformation matrix with the explicit transformation
parameters.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">Y</span> <span class="o">=</span> <span class="p">(</span><span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mi">0</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">X</span> <span class="o">-</span> <span class="n">X</span>
<span class="mi">0</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">b1</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">c0</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">c1</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">Y</span> <span class="o">-</span> <span class="n">Y</span>
</pre></div>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-python"><pre>A   = [[x y 1 0 0 0 -x*X -y*X -X]
       [0 0 0 x y 1 -x*Y -y*Y -Y]
        ...
        ...
      ]
x.T = [a0 a1 a2 b0 b1 b2 c0 c1 c3]</pre>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<p>In case of the affine transformation the coefficients c0 and c1 are 0.
Thus the system of equations is:</p>
<div class="highlight-python"><pre>A   = [[x y 1 0 0 0 -X]
       [0 0 0 x y 1 -Y]
        ...
        ...
      ]
x.T = [a0 a1 a2 b0 b1 b2 c3]</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>src</strong> : (N, 2) array</p>
<blockquote>
<div><p>source coordinates</p>
</div></blockquote>
<p><strong>dst</strong> : (N, 2) array</p>
<blockquote class="last">
<div><p>destination coordinates</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.ProjectiveTransform.inverse">
<tt class="descname">inverse</tt><big>(</big><em>coords</em><big>)</big><a class="headerlink" href="#skimage.transform.ProjectiveTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="similaritytransform">
<h2><a class="reference internal" href="#skimage.transform.SimilarityTransform" title="skimage.transform.SimilarityTransform"><tt class="xref py py-class docutils literal"><span class="pre">SimilarityTransform</span></tt></a><a class="headerlink" href="#similaritytransform" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.transform.SimilarityTransform">
<em class="property">class </em><tt class="descclassname">skimage.transform.</tt><tt class="descname">SimilarityTransform</tt><big>(</big><em>matrix=None</em>, <em>scale=None</em>, <em>rotation=None</em>, <em>translation=None</em><big>)</big><a class="headerlink" href="#skimage.transform.SimilarityTransform" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.transform._geometric.ProjectiveTransform</span></tt></p>
<p>2D similarity transformation of the form:</p>
<div class="highlight-python"><pre>X = a0*x - b0*y + a1 =
  = m*x*cos(rotation) + m*y*sin(rotation) + a1

Y = b0*x + a0*y + b1 =
  = m*x*sin(rotation) + m*y*cos(rotation) + b1</pre>
</div>
<p>where <tt class="docutils literal"><span class="pre">m</span></tt> is a zoom factor and the homogeneous transformation matrix is:</p>
<div class="highlight-python"><pre>[[a0  b0  a1]
 [b0  a0  b1]
 [0   0    1]]</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>matrix</strong> : (3, 3) array, optional</p>
<blockquote>
<div><p>Homogeneous transformation matrix.</p>
</div></blockquote>
<p><strong>scale</strong> : float, optional</p>
<blockquote>
<div><p>scale factor</p>
</div></blockquote>
<p><strong>rotation</strong> : float, optional</p>
<blockquote>
<div><p>rotation angle in counter-clockwise direction as radians</p>
</div></blockquote>
<p><strong>translation</strong> : (tx, ty) as array, list or tuple, optional</p>
<blockquote class="last">
<div><p>x, y translation parameters</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr><td><a class="reference internal" href="#skimage.transform.SimilarityTransform.estimate" title="skimage.transform.SimilarityTransform.estimate"><tt class="xref py py-obj docutils literal"><span class="pre">estimate</span></tt></a></td>
<td></td>
</tr>
<tr><td><a class="reference internal" href="#skimage.transform.SimilarityTransform.inverse" title="skimage.transform.SimilarityTransform.inverse"><tt class="xref py py-obj docutils literal"><span class="pre">inverse</span></tt></a></td>
<td></td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="skimage.transform.SimilarityTransform.__init__">
<tt class="descname">__init__</tt><big>(</big><em>matrix=None</em>, <em>scale=None</em>, <em>rotation=None</em>, <em>translation=None</em><big>)</big><a class="headerlink" href="#skimage.transform.SimilarityTransform.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.transform.SimilarityTransform.estimate">
<tt class="descname">estimate</tt><big>(</big><em>src</em>, <em>dst</em><big>)</big><a class="headerlink" href="#skimage.transform.SimilarityTransform.estimate" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the transformation matrix with the explicit parameters.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<p>The transformation is defined as:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">X</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">b0</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a1</span>
<span class="n">Y</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a0</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b1</span>
</pre></div>
</div>
<p>These equations can be transformed to the following form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="mi">0</span> <span class="o">=</span> <span class="n">a0</span><span class="o">*</span><span class="n">x</span> <span class="o">-</span> <span class="n">b0</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">a1</span> <span class="o">-</span> <span class="n">X</span>
<span class="mi">0</span> <span class="o">=</span> <span class="n">b0</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">a0</span><span class="o">*</span><span class="n">y</span> <span class="o">+</span> <span class="n">b1</span> <span class="o">-</span> <span class="n">Y</span>
</pre></div>
</div>
<p>which exist for each set of corresponding points, so we have a set of
N * 2 equations. The coefficients appear linearly so we can write
A x = 0, where:</p>
<div class="highlight-python"><pre>A   = [[x 1 -y 0 -X]
       [y 0  x 1 -Y]
        ...
        ...
      ]
x.T = [a0 a1 b0 b1 c3]</pre>
</div>
<p>In case of total least-squares the solution of this homogeneous system
of equations is the right singular vector of A which corresponds to the
smallest singular value normed by the coefficient c3.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>src</strong> : (N, 2) array</p>
<blockquote>
<div><p>source coordinates</p>
</div></blockquote>
<p><strong>dst</strong> : (N, 2) array</p>
<blockquote class="last">
<div><p>destination coordinates</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.transform.SimilarityTransform.inverse">
<tt class="descname">inverse</tt><big>(</big><em>coords</em><big>)</big><a class="headerlink" href="#skimage.transform.SimilarityTransform.inverse" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.SimilarityTransform.rotation">
<tt class="descname">rotation</tt><a class="headerlink" href="#skimage.transform.SimilarityTransform.rotation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.SimilarityTransform.scale">
<tt class="descname">scale</tt><a class="headerlink" href="#skimage.transform.SimilarityTransform.scale" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="skimage.transform.SimilarityTransform.translation">
<tt class="descname">translation</tt><a class="headerlink" href="#skimage.transform.SimilarityTransform.translation" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr><td><a class="reference internal" href="#skimage.transform.estimate_transform" title="skimage.transform.estimate_transform"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.estimate_transform</span></tt></a>(ttype,&nbsp;...)</td>
<td>Estimate 2D geometric transformation parameters.</td>
</tr>
<tr><td><a class="reference internal" href="#skimage.transform.fast_homography" title="skimage.transform.fast_homography"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.fast_homography</span></tt></a></td>
<td>Projective transformation (homography).</td>
</tr>
<tr><td><a class="reference internal" href="#skimage.transform.frt2" title="skimage.transform.frt2"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.frt2</span></tt></a>(a)</td>
<td>Compute the 2-dimensional finite radon transform (FRT) for an n x n</td>
</tr>
<tr><td><a class="reference internal" href="#skimage.transform.homography" title="skimage.transform.homography"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.homography</span></tt></a>(image,&nbsp;H[,&nbsp;...])</td>
<td>Perform a projective transformation (homography) on an image.</td>
</tr>
<tr><td><a class="reference internal" href="#skimage.transform.hough" title="skimage.transform.hough"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.hough</span></tt></a>(img[,&nbsp;theta])</td>
<td>Perform a straight line Hough transform.</td>
</tr>
<tr><td><a class="reference internal" href="#skimage.transform.ifrt2" title="skimage.transform.ifrt2"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.ifrt2</span></tt></a>(a)</td>
<td>Compute the 2-dimensional inverse finite radon transform (iFRT) for</td>
</tr>
<tr><td><a class="reference internal" href="#skimage.transform.integral_image" title="skimage.transform.integral_image"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.integral_image</span></tt></a>(x)</td>
<td>Integral image / summed area table.</td>
</tr>
<tr><td><a class="reference internal" href="#skimage.transform.integrate" title="skimage.transform.integrate"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.integrate</span></tt></a>(ii,&nbsp;r0,&nbsp;c0,&nbsp;r1,&nbsp;c1)</td>
<td>Use an integral image to integrate over a given window.</td>
</tr>
<tr><td><a class="reference internal" href="#skimage.transform.iradon" title="skimage.transform.iradon"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.iradon</span></tt></a>(radon_image[,&nbsp;...])</td>
<td>Inverse radon transform.</td>
</tr>
<tr><td><a class="reference internal" href="#skimage.transform.probabilistic_hough" title="skimage.transform.probabilistic_hough"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.probabilistic_hough</span></tt></a>(img[,&nbsp;...])</td>
<td>Performs a progressive probabilistic line Hough transform and returns the detected lines.</td>
</tr>
<tr><td><a class="reference internal" href="#skimage.transform.radon" title="skimage.transform.radon"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.radon</span></tt></a>(image[,&nbsp;theta])</td>
<td>Calculates the radon transform of an image given specified projection angles.</td>
</tr>
<tr><td><a class="reference internal" href="#skimage.transform.swirl" title="skimage.transform.swirl"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.swirl</span></tt></a>(image[,&nbsp;center,&nbsp;...])</td>
<td>Perform a swirl transformation.</td>
</tr>
<tr><td><a class="reference internal" href="#skimage.transform.warp" title="skimage.transform.warp"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.transform.warp</span></tt></a>(image[,&nbsp;inverse_map,&nbsp;...])</td>
<td>Warp an image according to a given coordinate transformation.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="estimate-transform">
<h2>estimate_transform<a class="headerlink" href="#estimate-transform" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.estimate_transform">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">estimate_transform</tt><big>(</big><em>ttype</em>, <em>src</em>, <em>dst</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#skimage.transform.estimate_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate 2D geometric transformation parameters.</p>
<p>You can determine the over-, well- and under-determined parameters
with the total least-squares method.</p>
<p>Number of source and destination coordinates must match.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>ttype</strong> : {&#8216;similarity&#8217;, &#8216;affine&#8217;, &#8216;projective&#8217;, &#8216;polynomial&#8217;}</p>
<blockquote>
<div><p>Type of transform.</p>
</div></blockquote>
<p><strong>kwargs</strong> : array or int</p>
<blockquote>
<div><p>Function parameters (src, dst, n, angle):</p>
<div class="highlight-python"><pre>NAME / TTYPE        FUNCTION PARAMETERS
'similarity'        `src, `dst`
'affine'            `src, `dst`
'projective'        `src, `dst`
'polynomial'        `src, `dst`, `order` (polynomial order)</pre>
</div>
<p>Also see examples below.</p>
</div></blockquote>
</td>
</tr>
<tr class="field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>tform</strong> : <tt class="xref py py-class docutils literal"><span class="pre">GeometricTransform</span></tt></p>
<blockquote class="last">
<div><p>Transform object containing the transformation parameters and providing
access to forward and inverse transformation functions.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">transform</span> <span class="k">as</span> <span class="n">tf</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># estimate transformation parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">src</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">12</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">20</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">estimate_transform</span><span class="p">(</span><span class="s">&#39;similarity&#39;</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">(</span><span class="n">tform</span><span class="p">(</span><span class="n">src</span><span class="p">))</span> <span class="c"># == src</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># warp image using the estimated transformation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">inverse_map</span><span class="o">=</span><span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># create transformation with explicit parameters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform2</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">SimilarityTransform</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform2</span><span class="o">.</span><span class="n">compose_implicit</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">translation</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># unite transformations, applied in order from left to right</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform3</span> <span class="o">=</span> <span class="n">tform</span> <span class="o">+</span> <span class="n">tform2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tform3</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="c"># == tform2(tform(src))</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="fast-homography">
<h2>fast_homography<a class="headerlink" href="#fast-homography" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.fast_homography">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">fast_homography</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.transform.fast_homography" title="Permalink to this definition">¶</a></dt>
<dd><p>Projective transformation (homography).</p>
<p>Perform a projective transformation (homography) of a
floating point image, using bi-linear interpolation.</p>
<p>For each pixel, given its homogeneous coordinate <img class="math" src="../_images/math/1aa9d7913003fccfc89a3c2961147dac616653a4.png" alt="\mathbf{x}
= [x, y, 1]^T"/>, its target position is calculated by multiplying
with the given matrix, <img class="math" src="../_images/math/b1902d279ba37d60bdce4e0e987b7cd19d48974e.png" alt="H"/>, to give <img class="math" src="../_images/math/42a03cd1c073037bd9cd9e953d4ab607bb70d4c5.png" alt="H \mathbf{x}"/>.
E.g., to rotate by theta degrees clockwise, the matrix should be</p>
<div class="highlight-python"><pre>[[cos(theta) -sin(theta) 0]
 [sin(theta)  cos(theta) 0]
 [0            0         1]]</pre>
</div>
<p>or, to translate x by 10 and y by 20,</p>
<div class="highlight-python"><pre>[[1 0 10]
 [0 1 20]
 [0 0 1 ]].</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>H</strong> : array of shape <tt class="docutils literal"><span class="pre">(3,</span> <span class="pre">3)</span></tt></p>
<blockquote>
<div><p>Transformation matrix H that defines the homography.</p>
</div></blockquote>
<p><strong>output_shape</strong> : tuple (rows, cols)</p>
<blockquote>
<div><p>Shape of the output image generated.</p>
</div></blockquote>
<p><strong>order</strong> : int</p>
<blockquote>
<div><p>Order of splines used in interpolation.</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8216;constant&#8217;, &#8216;mirror&#8217;, &#8216;wrap&#8217;}</p>
<blockquote>
<div><p>How to handle values outside the image borders.</p>
</div></blockquote>
<p><strong>cval</strong> : string</p>
<blockquote class="last">
<div><p>Used in conjunction with mode &#8216;C&#8217; (constant), the value
outside the image boundaries.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="frt2">
<h2>frt2<a class="headerlink" href="#frt2" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.frt2">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">frt2</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#skimage.transform.frt2" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 2-dimensional finite radon transform (FRT) for an n x n
integer array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>a</strong> : array_like</p>
<blockquote>
<div><p>A 2-D square n x n integer array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>FRT</strong> : 2-D ndarray</p>
<blockquote class="last">
<div><p>Finite Radon Transform array of (n+1) x n integer coefficients.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#skimage.transform.ifrt2" title="skimage.transform.ifrt2"><tt class="xref py py-obj docutils literal"><span class="pre">ifrt2</span></tt></a></dt>
<dd>The two-dimensional inverse FRT.</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The FRT has a unique inverse iff n is prime. [FRT]
The idea for this algorithm is due to Vlad Negnevitski.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="frt" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[FRT]</a></td><td>A. Kingston and I. Svalbe, &#8220;Projective transforms on periodic
discrete image arrays,&#8221; in P. Hawkes (Ed), Advances in Imaging
and Electron Physics, 139 (2006)</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Generate a test image:
Use a prime number for the array dimensions</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">SIZE</span> <span class="o">=</span> <span class="mi">59</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Finite Radon Transform:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">frt2</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<p>Plot the results:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Angle&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Translation&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="homography">
<h2>homography<a class="headerlink" href="#homography" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.homography">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">homography</tt><big>(</big><em>image</em>, <em>H</em>, <em>output_shape=None</em>, <em>order=1</em>, <em>mode='constant'</em>, <em>cval=0.0</em><big>)</big><a class="headerlink" href="#skimage.transform.homography" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a projective transformation (homography) on an image.</p>
<p>For each pixel, given its homogeneous coordinate <img class="math" src="../_images/math/1aa9d7913003fccfc89a3c2961147dac616653a4.png" alt="\mathbf{x}
= [x, y, 1]^T"/>, its target position is calculated by multiplying
with the given matrix, <img class="math" src="../_images/math/b1902d279ba37d60bdce4e0e987b7cd19d48974e.png" alt="H"/>, to give <img class="math" src="../_images/math/42a03cd1c073037bd9cd9e953d4ab607bb70d4c5.png" alt="H \mathbf{x}"/>.
E.g., to rotate by theta degrees clockwise, the matrix should be</p>
<div class="highlight-python"><pre>[[cos(theta) -sin(theta) 0]
 [sin(theta)  cos(theta) 0]
 [0            0         1]]</pre>
</div>
<p>or, to translate x by 10 and y by 20,</p>
<div class="highlight-python"><pre>[[1 0 10]
 [0 1 20]
 [0 0 1 ]].</pre>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>H</strong> : array of shape <tt class="docutils literal"><span class="pre">(3,</span> <span class="pre">3)</span></tt></p>
<blockquote>
<div><p>Transformation matrix H that defines the homography.</p>
</div></blockquote>
<p><strong>output_shape</strong> : tuple (rows, cols)</p>
<blockquote>
<div><p>Shape of the output image generated.</p>
</div></blockquote>
<p><strong>order</strong> : int</p>
<blockquote>
<div><p>Order of splines used in interpolation.</p>
</div></blockquote>
<p><strong>mode</strong> : string</p>
<blockquote>
<div><p>How to handle values outside the image borders.  Passed as-is
to ndimage.</p>
</div></blockquote>
<p><strong>cval</strong> : string</p>
<blockquote class="last">
<div><p>Used in conjunction with mode &#8216;constant&#8217;, the value outside
the image boundaries.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># rotate by 90 degrees around origin and shift down by 2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span>
<span class="go">array([[1, 2, 3],</span>
<span class="go">       [4, 5, 6],</span>
<span class="go">       [7, 8, 9]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">theta</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span><span class="mi">2</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span><span class="mi">0</span><span class="p">,</span>             <span class="mi">0</span><span class="p">,</span>            <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x90</span> <span class="o">=</span> <span class="n">homography</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x90</span>
<span class="go">array([[3, 6, 9],</span>
<span class="go">       [2, 5, 8],</span>
<span class="go">       [1, 4, 7]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># translate right by 2 and down by 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">255</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span>
<span class="go">array([[  0,   0,   0,   0,   0],</span>
<span class="go">       [  0, 255,   0,   0,   0],</span>
<span class="go">       [  0,   0,   0,   0,   0],</span>
<span class="go">       [  0,   0,   0,   0,   0],</span>
<span class="go">       [  0,   0,   0,   0,   0]], dtype=uint8)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mf">1.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">2.</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">],</span>
<span class="gp">... </span>              <span class="p">[</span> <span class="mf">0.</span><span class="p">,</span>  <span class="mf">0.</span><span class="p">,</span>  <span class="mf">1.</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y21</span> <span class="o">=</span> <span class="n">homography</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y21</span>
<span class="go">array([[  0,   0,   0,   0,   0],</span>
<span class="go">       [  0,   0,   0,   0,   0],</span>
<span class="go">       [  0,   0,   0, 255,   0],</span>
<span class="go">       [  0,   0,   0,   0,   0],</span>
<span class="go">       [  0,   0,   0,   0,   0]], dtype=uint8)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="hough">
<h2>hough<a class="headerlink" href="#hough" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.hough">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">hough</tt><big>(</big><em>img</em>, <em>theta=None</em><big>)</big><a class="headerlink" href="#skimage.transform.hough" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a straight line Hough transform.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>img</strong> : (M, N) ndarray</p>
<blockquote>
<div><p>Input image with nonzero values representing edges.</p>
</div></blockquote>
<p><strong>theta</strong> : 1D ndarray of double</p>
<blockquote>
<div><p>Angles at which to compute the transform, in radians.
Defaults to -pi/2 .. pi/2</p>
</div></blockquote>
</td>
</tr>
<tr class="field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>H</strong> : 2-D ndarray of uint64</p>
<blockquote>
<div><p>Hough transform accumulator.</p>
</div></blockquote>
<p><strong>distances</strong> : ndarray</p>
<blockquote>
<div><p>Distance values.</p>
</div></blockquote>
<p><strong>theta</strong> : ndarray</p>
<blockquote class="last">
<div><p>Angles at which the transform was computed.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Generate a test image:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[:,</span> <span class="mi">65</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span><span class="p">[</span><span class="mi">35</span><span class="p">:</span><span class="mi">45</span><span class="p">,</span> <span class="mi">35</span><span class="p">:</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">90</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">img</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.95</span>
</pre></div>
</div>
<p>Apply the Hough transform:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">hough</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<p>Plot the results:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">bone</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Angle (degree)&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Distance </span><span class="si">%d</span><span class="s"> (pixel)&#39;</span> <span class="o">%</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">hough</span>

<span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="n">img</span><span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">img</span><span class="p">[:,</span> <span class="mi">65</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">img</span><span class="p">[</span><span class="mi">35</span><span class="p">:</span><span class="mi">45</span><span class="p">,</span> <span class="mi">35</span><span class="p">:</span><span class="mi">50</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">90</span><span class="p">):</span>
    <span class="n">img</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">img</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.95</span>

<span class="n">out</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">hough</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">gray</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Input image&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">bone</span><span class="p">,</span>
           <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                   <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">angles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s">&#39;Hough transform&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">&#39;Angle (degree)&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">&#39;Distance (pixel)&#39;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">wspace</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
<p>(<a class="reference external" href="../plots/hough_tf.py">Source code</a>, <a class="reference external" href="../plots/hough_tf.png">png</a>)</p>
<div class="figure">
<img alt="../_images/hough_tf.png" src="../_images/hough_tf.png" />
</div>
</dd></dl>

</div>
<div class="section" id="ifrt2">
<h2>ifrt2<a class="headerlink" href="#ifrt2" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.ifrt2">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">ifrt2</tt><big>(</big><em>a</em><big>)</big><a class="headerlink" href="#skimage.transform.ifrt2" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the 2-dimensional inverse finite radon transform (iFRT) for
an (n+1) x n integer array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>a</strong> : array_like</p>
<blockquote>
<div><p>A 2-D (n+1) row x n column integer array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>iFRT</strong> : 2-D n x n ndarray</p>
<blockquote class="last">
<div><p>Inverse Finite Radon Transform array of n x n integer coefficients.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><a class="reference internal" href="#skimage.transform.frt2" title="skimage.transform.frt2"><tt class="xref py py-obj docutils literal"><span class="pre">frt2</span></tt></a></dt>
<dd>The two-dimensional FRT</dd>
</dl>
</div>
<p class="rubric">Notes</p>
<p>The FRT has a unique inverse iff n is prime.
See <a class="reference internal" href="#r59">[R59]</a> for an overview.
The idea for this algorithm is due to Vlad Negnevitski.</p>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r59" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[R59]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id3">2</a>)</em> A. Kingston and I. Svalbe, &#8220;Projective transforms on periodic
discrete image arrays,&#8221; in P. Hawkes (Ed), Advances in Imaging
and Electron Physics, 139 (2006)</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">SIZE</span> <span class="o">=</span> <span class="mi">59</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">(</span><span class="n">SIZE</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Finite Radon Transform:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">frt2</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
<p>Apply the Inverse Finite Radon Transform to recover the input</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fi</span> <span class="o">=</span> <span class="n">ifrt2</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>Check that it&#8217;s identical to the original</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">img</span><span class="o">-</span><span class="n">fi</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="integral-image">
<h2>integral_image<a class="headerlink" href="#integral-image" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.integral_image">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">integral_image</tt><big>(</big><em>x</em><big>)</big><a class="headerlink" href="#skimage.transform.integral_image" title="Permalink to this definition">¶</a></dt>
<dd><p>Integral image / summed area table.</p>
<p>The integral image contains the sum of all elements above and to the
left of it, i.e.:</p>
<div class="math">
<p><img src="../_images/math/60eb18acdabe921f0fcbc69cf1dfc9fe4934bb1d.png" alt="S[m, n] = \sum_{i \leq m} \sum_{j \leq n} X[i, j]" /></p>
</div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>x</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
</td>
</tr>
<tr class="field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>S</strong> : ndarray</p>
<blockquote class="last">
<div><p>Integral image / summed area table.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r60" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[R60]</a></td><td>F.C. Crow, &#8220;Summed-area tables for texture mapping,&#8221;
ACM SIGGRAPH Computer Graphics, vol. 18, 1984, pp. 207-212.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="integrate">
<h2>integrate<a class="headerlink" href="#integrate" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.integrate">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">integrate</tt><big>(</big><em>ii</em>, <em>r0</em>, <em>c0</em>, <em>r1</em>, <em>c1</em><big>)</big><a class="headerlink" href="#skimage.transform.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Use an integral image to integrate over a given window.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>ii</strong> : ndarray</p>
<blockquote>
<div><p>Integral image.</p>
</div></blockquote>
<p><strong>r0, c0</strong> : int</p>
<blockquote>
<div><p>Top-left corner of block to be summed.</p>
</div></blockquote>
<p><strong>r1, c1</strong> : int</p>
<blockquote>
<div><p>Bottom-right corner of block to be summed.</p>
</div></blockquote>
</td>
</tr>
<tr class="field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>S</strong> : int</p>
<blockquote class="last">
<div><p>Integral (sum) over the given window.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="iradon">
<h2>iradon<a class="headerlink" href="#iradon" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.iradon">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">iradon</tt><big>(</big><em>radon_image</em>, <em>theta=None</em>, <em>output_size=None</em>, <em>filter='ramp'</em>, <em>interpolation='linear'</em><big>)</big><a class="headerlink" href="#skimage.transform.iradon" title="Permalink to this definition">¶</a></dt>
<dd><p>Inverse radon transform.</p>
<p>Reconstruct an image from the radon transform, using the filtered
back projection algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>radon_image</strong> : array_like, dtype=float</p>
<blockquote>
<div><p>Image containing radon transform (sinogram). Each column of
the image corresponds to a projection along a different angle.</p>
</div></blockquote>
<p><strong>theta</strong> : array_like, dtype=float, optional</p>
<blockquote>
<div><p>Reconstruction angles (in degrees). Default: m angles evenly spaced
between 0 and 180 (if the shape of <cite>radon_image</cite> is nxm)</p>
</div></blockquote>
<p><strong>output_size</strong> : int</p>
<blockquote>
<div><p>Number of rows and columns in the reconstruction.</p>
</div></blockquote>
<p><strong>filter</strong> : str, optional (default ramp)</p>
<blockquote>
<div><p>Filter used in frequency domain filtering. Ramp filter used by default.
Filters available: ramp, shepp-logan, cosine, hamming, hann
Assign None to use no filter.</p>
</div></blockquote>
<p><strong>interpolation</strong> : str, optional (default linear)</p>
<blockquote>
<div><p>Interpolation method used in reconstruction.
Methods available: nearest, linear.</p>
</div></blockquote>
</td>
</tr>
<tr class="field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>output</strong> : ndarray</p>
<blockquote class="last">
<div><p>Reconstructed image.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>It applies the fourier slice theorem to reconstruct an image by
multiplying the frequency domain of the filter with the FFT of the
projection data. This algorithm is called filtered back projection.</p>
</dd></dl>

</div>
<div class="section" id="probabilistic-hough">
<h2>probabilistic_hough<a class="headerlink" href="#probabilistic-hough" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.probabilistic_hough">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">probabilistic_hough</tt><big>(</big><em>img</em>, <em>threshold=10</em>, <em>line_length=50</em>, <em>line_gap=10</em>, <em>theta=None</em><big>)</big><a class="headerlink" href="#skimage.transform.probabilistic_hough" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs a progressive probabilistic line Hough transform and returns the detected lines.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>img</strong> : (M, N) ndarray</p>
<blockquote>
<div><p>Input image with nonzero values representing edges.</p>
</div></blockquote>
<p><strong>threshold</strong> : int</p>
<blockquote>
<div><p>Threshold</p>
</div></blockquote>
<p><strong>line_length</strong> : int, optional (default 50)</p>
<blockquote>
<div><p>Minimum accepted length of detected lines.
Increase the parameter to extract longer lines.</p>
</div></blockquote>
<p><strong>line_gap</strong> : int, optional, (default 10)</p>
<blockquote>
<div><p>Maximum gap between pixels to still form a line.
Increase the parameter to merge broken lines more aggresively.</p>
</div></blockquote>
<p><strong>theta</strong> : 1D ndarray, dtype=double, optional, default (-pi/2 .. pi/2)</p>
<blockquote>
<div><p>Angles at which to compute the transform, in radians.</p>
</div></blockquote>
</td>
</tr>
<tr class="field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>lines</strong> : list</p>
<blockquote class="last">
<div><p>List of lines identified, lines in format ((x0, y0), (x1, y0)), indicating
line start and end.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r61" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[R61]</a></td><td>C. Galamhos, J. Matas and J. Kittler,&#8221;Progressive probabilistic Hough
transform for line detection&#8221;, in  IEEE Computer Society Conference on
Computer Vision and Pattern Recognition, 1999.</td></tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="radon">
<h2>radon<a class="headerlink" href="#radon" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.radon">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">radon</tt><big>(</big><em>image</em>, <em>theta=None</em><big>)</big><a class="headerlink" href="#skimage.transform.radon" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the radon transform of an image given specified
projection angles.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : array_like, dtype=float</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>theta</strong> : array_like, dtype=float, optional (default np.arange(180))</p>
<blockquote>
<div><p>Projection angles (in degrees).</p>
</div></blockquote>
</td>
</tr>
<tr class="field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>output</strong> : ndarray</p>
<blockquote class="last">
<div><p>Radon transform (sinogram).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="swirl">
<h2>swirl<a class="headerlink" href="#swirl" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.swirl">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">swirl</tt><big>(</big><em>image</em>, <em>center=None</em>, <em>strength=1</em>, <em>radius=100</em>, <em>rotation=0</em>, <em>output_shape=None</em>, <em>order=1</em>, <em>mode='constant'</em>, <em>cval=0</em><big>)</big><a class="headerlink" href="#skimage.transform.swirl" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a swirl transformation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>center</strong> : (x,y) tuple or (2,) ndarray</p>
<blockquote>
<div><p>Center coordinate of transformation.</p>
</div></blockquote>
<p><strong>strength</strong> : float</p>
<blockquote>
<div><p>The amount of swirling applied.</p>
</div></blockquote>
<p><strong>radius</strong> : float</p>
<blockquote>
<div><p>The extent of the swirl in pixels.  The effect dies out
rapidly beyond <cite>radius</cite>.</p>
</div></blockquote>
<p><strong>rotation</strong> : float</p>
<blockquote>
<div><p>Additional rotation applied to the image.</p>
</div></blockquote>
</td>
</tr>
<tr class="field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>swirled</strong> : ndarray</p>
<blockquote class="last">
<div><p>Swirled version of the input.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="warp">
<h2>warp<a class="headerlink" href="#warp" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.transform.warp">
<tt class="descclassname">skimage.transform.</tt><tt class="descname">warp</tt><big>(</big><em>image</em>, <em>inverse_map=None</em>, <em>map_args={}</em>, <em>output_shape=None</em>, <em>order=1</em>, <em>mode='constant'</em>, <em>cval=0.0</em>, <em>reverse_map=None</em><big>)</big><a class="headerlink" href="#skimage.transform.warp" title="Permalink to this definition">¶</a></dt>
<dd><p>Warp an image according to a given coordinate transformation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>image</strong> : 2-D array</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>inverse_map</strong> : transformation object, callable xy = f(xy, <a href="#id6"><span class="problematic" id="id7">**</span></a>kwargs)</p>
<blockquote>
<div><p>Inverse coordinate map. A function that transforms a (N, 2) array of
<tt class="docutils literal"><span class="pre">(x,</span> <span class="pre">y)</span></tt> coordinates in the <em>output image</em> into their corresponding
coordinates in the <em>source image</em> (e.g. a transformation object or its
inverse).</p>
</div></blockquote>
<p><strong>map_args</strong> : dict, optional</p>
<blockquote>
<div><p>Keyword arguments passed to <cite>inverse_map</cite>.</p>
</div></blockquote>
<p><strong>output_shape</strong> : tuple (rows, cols)</p>
<blockquote>
<div><p>Shape of the output image generated.</p>
</div></blockquote>
<p><strong>order</strong> : int</p>
<blockquote>
<div><p>Order of splines used in interpolation. See
<cite>scipy.ndimage.map_coordinates</cite> for detail.</p>
</div></blockquote>
<p><strong>mode</strong> : string</p>
<blockquote>
<div><p>How to handle values outside the image borders.  See
<cite>scipy.ndimage.map_coordinates</cite> for detail.</p>
</div></blockquote>
<p><strong>cval</strong> : string</p>
<blockquote class="last">
<div><p>Used in conjunction with mode &#8216;constant&#8217;, the value outside
the image boundaries.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<p>Shift an image to the right:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">camera</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">shift_right</span><span class="p">(</span><span class="n">xy</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">xy</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">10</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">xy</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">warp</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">shift_right</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
        </div>
        <div class="clearer"></div>
    </div>
    </div>

    <div class="footer-wrapper">
      
    <div class="footer">
        &copy; Copyright 2011, the scikits-image team.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.0.8.
    </div>
    </div>

  </body>
</html>