


<!DOCTYPE html>
<html lang="en">
<head>
        <title>Module: graph &mdash; skimage v0.11dev docs</title>
    
    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link href="../_static/css/bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="../_static/css/custom.css" rel="stylesheet" type="text/css">
    <link href="http://fonts.googleapis.com/css?family=Raleway" rel="stylesheet" type="text/css">
    
    <script src="http://code.jquery.com/jquery-latest.js"></script>
    <script src="../_static/js/bootstrap.min.js"></script>
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.11dev',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <link rel="top" title="skimage v0.11dev docs" href="../index.html" />
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
    <link rel="shortcut icon" href="../_static/favicon.ico">
</head>
<body class="container">
    <a href="http://scikit-image.org" class="logo"><img src="../_static/img/logo.png" alt=""></a>
    <div class="clearfix"></div>
    <div class="navbar">
        <div class="navbar-inner">
            <ul class="nav">
                <li><a href="/">Home</a></li>
<li><a href="/download.html">Download</a></li>
<li><a href="/docs/dev/auto_examples">Gallery</a></li>
<li><a href="/docs/dev">Documentation</a></li>
<li><a href="https://github.com/scikit-image/scikit-image">
    <img src="_static/GitHub-Mark-32px.png" style="height: 15px; width: 15px;
                                                   display: inline; float: none;
                                                   padding-bottom: 3px;">
    Source</a>
</li>
            </ul>
            <form class="navbar-form pull-right" action="../search.html" method="get">
                <input type="text" class="search span3" name="q" placeholder="Search documentation ...">
                <input type="hidden" name="check_keywords" value="yes" >
                <input type="hidden" name="area" value="default" >
            </form>
        </div>
    </div>
    <div class="row">
        <div class="span9">
            
  <div class="section" id="module-skimage.graph">
<span id="module-graph"></span><h1>Module: <tt class="xref py py-mod docutils literal"><span class="pre">graph</span></tt><a class="headerlink" href="#module-skimage.graph" title="Permalink to this headline">¶</a></h1>
<div class="section" id="mcp">
<h2><a class="reference internal" href="#skimage.graph.MCP" title="skimage.graph.MCP"><tt class="xref py py-class docutils literal"><span class="pre">MCP</span></tt></a><a class="headerlink" href="#mcp" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.graph.MCP">
<em class="property">class </em><tt class="descclassname">skimage.graph.</tt><tt class="descname">MCP</tt><big>(</big><em>costs</em>, <em>offsets=None</em>, <em>fully_connected=True</em>, <em>sampling=None</em><big>)</big><a class="headerlink" href="#skimage.graph.MCP" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/2.7/library/functions.html#object" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></a></p>
<p>A class for finding the minimum cost path through a given n-d costs array.</p>
<p>Given an n-d costs array, this class can be used to find the minimum-cost
path through that array from any set of points to any other set of points.
Basic usage is to initialize the class and call find_costs() with a one
or more starting indices (and an optional list of end indices). After
that, call traceback() one or more times to find the path from any given
end-position to the closest starting index. New paths through the same
costs array can be found by calling find_costs() repeatedly.</p>
<p>The cost of a path is calculated simply as the sum of the values of the
<cite>costs</cite> array at each point on the path. The class MCP_Geometric, on the
other hand, accounts for the fact that diagonal vs. axial moves are of
different lengths, and weights the path cost accordingly.</p>
<p>Array elements with infinite or negative costs will simply be ignored, as
will paths whose cumulative cost overflows to infinite.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>costs</strong> : ndarray</p>
<p><strong>offsets</strong> : iterable, optional</p>
<blockquote>
<div><p>A list of offset tuples: each offset specifies a valid move from a
given n-d position.
If not provided, offsets corresponding to a singly- or fully-connected
n-d neighborhood will be constructed with make_offsets(), using the
<cite>fully_connected</cite> parameter value.</p>
</div></blockquote>
<p><strong>fully_connected</strong> : bool, optional</p>
<blockquote>
<div><p>If no <cite>offsets</cite> are provided, this determines the connectivity of the
generated neighborhood. If true, the path may go along diagonals
between elements of the <cite>costs</cite> array; otherwise only axial moves are
permitted.</p>
</div></blockquote>
<p><strong>sampling</strong> : tuple, optional</p>
<blockquote class="last">
<div><p>For each dimension, specifies the distance between two cells/voxels.
If not given or None, the distance is assumed unit.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<dl class="method">
<dt id="skimage.graph.MCP.__init__">
<tt class="descname">__init__</tt><big>(</big><em>costs</em>, <em>offsets=None</em>, <em>fully_connected=True</em>, <em>sampling=None</em><big>)</big><a class="headerlink" href="#skimage.graph.MCP.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>See class documentation.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.graph.MCP.find_costs">
<tt class="descname">find_costs</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.graph.MCP.find_costs" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the minimum-cost path from the given starting points.</p>
<p>This method finds the minimum-cost path to the specified ending
indices from any one of the specified starting indices. If no end
positions are given, then the minimum-cost path to every position in
the costs array will be found.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>starts</strong> : iterable</p>
<blockquote>
<div><p>A list of n-d starting indices (where n is the dimension of the
<cite>costs</cite> array). The minimum cost path to the closest/cheapest
starting point will be found.</p>
</div></blockquote>
<p><strong>ends</strong> : iterable, optional</p>
<blockquote>
<div><p>A list of n-d ending indices.</p>
</div></blockquote>
<p><strong>find_all_ends</strong> : bool, optional</p>
<blockquote>
<div><p>If &#8216;True&#8217; (default), the minimum-cost-path to every specified
end-position will be found; otherwise the algorithm will stop when
a a path is found to any end-position. (If no <cite>ends</cite> were
specified, then this parameter has no effect.)</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>cumulative_costs</strong> : ndarray</p>
<blockquote>
<div><p>Same shape as the <cite>costs</cite> array; this array records the minimum
cost path from the nearest/cheapest starting index to each index
considered. (If <cite>ends</cite> were specified, not all elements in the
array will necessarily be considered: positions not evaluated will
have a cumulative cost of inf. If <cite>find_all_ends</cite> is &#8216;False&#8217;, only
one of the specified end-positions will have a finite cumulative
cost.)</p>
</div></blockquote>
<p><strong>traceback</strong> : ndarray</p>
<blockquote class="last">
<div><p>Same shape as the <cite>costs</cite> array; this array contains the offset to
any given index from its predecessor index. The offset indices
index into the <cite>offsets</cite> attribute, which is a array of n-d
offsets. In the 2-d case, if offsets[traceback[x, y]] is (-1, -1),
that means that the predecessor of [x, y] in the minimum cost path
to some start position is [x+1, y+1]. Note that if the
offset_index is -1, then the given index was not considered.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="skimage.graph.MCP.goal_reached">
<tt class="descname">goal_reached</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.graph.MCP.goal_reached" title="Permalink to this definition">¶</a></dt>
<dd><p>int goal_reached(int index, float cumcost)
This method is called each iteration after popping an index
from the heap, before examining the neighbours.</p>
<p>This method can be overloaded to modify the behavior of the MCP
algorithm. An example might be to stop the algorithm when a
certain cumulative cost is reached, or when the front is a
certain distance away from the seed point.</p>
<p>This method should return 1 if the algorithm should not check
the current point&#8217;s neighbours and 2 if the algorithm is now
done.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.graph.MCP.traceback">
<tt class="descname">traceback</tt><big>(</big><em>end</em><big>)</big><a class="headerlink" href="#skimage.graph.MCP.traceback" title="Permalink to this definition">¶</a></dt>
<dd><p>Trace a minimum cost path through the pre-calculated traceback array.</p>
<p>This convenience function reconstructs the the minimum cost path to a
given end position from one of the starting indices provided to
find_costs(), which must have been called previously. This function
can be called as many times as desired after find_costs() has been
run.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>end</strong> : iterable</p>
<blockquote>
<div><p>An n-d index into the <cite>costs</cite> array.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>traceback</strong> : list of n-d tuples</p>
<blockquote class="last">
<div><p>A list of indices into the <cite>costs</cite> array, starting with one of
the start positions passed to find_costs(), and ending with the
given <cite>end</cite> index. These indices specify the minimum-cost path
from any given start index to the <cite>end</cite> index. (The total cost
of that path can be read out from the <cite>cumulative_costs</cite> array
returned by find_costs().)</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="mcp-connect">
<h2><a class="reference internal" href="#skimage.graph.MCP_Connect" title="skimage.graph.MCP_Connect"><tt class="xref py py-class docutils literal"><span class="pre">MCP_Connect</span></tt></a><a class="headerlink" href="#mcp-connect" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.graph.MCP_Connect">
<em class="property">class </em><tt class="descclassname">skimage.graph.</tt><tt class="descname">MCP_Connect</tt><a class="headerlink" href="#skimage.graph.MCP_Connect" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.graph._mcp.MCP</span></tt></p>
<p>Connect source points using the distance-weighted minimum cost function.</p>
<p>A front is grown from each seed point simultaneously, while the
origin of the front is tracked as well. When two fronts meet,
create_connection() is called. This method must be overloaded to
deal with the found edges in a way that is appropriate for the
application.</p>
<dl class="method">
<dt id="skimage.graph.MCP_Connect.__init__">
<tt class="descname">__init__</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.graph.MCP_Connect.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>x.__init__(...) initializes x; see help(type(x)) for signature</p>
</dd></dl>

<dl class="method">
<dt id="skimage.graph.MCP_Connect.create_connection">
<tt class="descname">create_connection</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.graph.MCP_Connect.create_connection" title="Permalink to this definition">¶</a></dt>
<dd><p>create_connection id1, id2, pos1, pos2, cost1, cost2)</p>
<p>Overload this method to keep track of the connections that are
found during MCP processing. Note that a connection with the
same ids can be found multiple times (but with different
positions and costs).</p>
<p>At the time that this method is called, both points are &#8220;frozen&#8221;
and will not be visited again by the MCP algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>id1</strong> : int</p>
<blockquote>
<div><p>The seed point id where the first neighbor originated from.</p>
</div></blockquote>
<p><strong>id2</strong> : int</p>
<blockquote>
<div><p>The seed point id where the second neighbor originated from.</p>
</div></blockquote>
<p><strong>pos1</strong> : tuple</p>
<blockquote>
<div><p>The index of of the first neighbour in the connection.</p>
</div></blockquote>
<p><strong>pos2</strong> : tuple</p>
<blockquote>
<div><p>The index of of the second neighbour in the connection.</p>
</div></blockquote>
<p><strong>cost1</strong> : float</p>
<blockquote>
<div><p>The cumulative cost at <cite>pos1</cite>.</p>
</div></blockquote>
<p><strong>cost2</strong> : float</p>
<blockquote class="last">
<div><p>The cumulative costs at <cite>pos2</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="mcp-flexible">
<h2><a class="reference internal" href="#skimage.graph.MCP_Flexible" title="skimage.graph.MCP_Flexible"><tt class="xref py py-class docutils literal"><span class="pre">MCP_Flexible</span></tt></a><a class="headerlink" href="#mcp-flexible" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.graph.MCP_Flexible">
<em class="property">class </em><tt class="descclassname">skimage.graph.</tt><tt class="descname">MCP_Flexible</tt><big>(</big><em>costs</em>, <em>offsets=None</em>, <em>fully_connected=True</em>, <em>sampling=None</em><big>)</big><a class="headerlink" href="#skimage.graph.MCP_Flexible" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.graph._mcp.MCP</span></tt></p>
<p>Find minimum cost paths through an N-d costs array.</p>
<p>See the documentation for MCP for full details. This class differs from
MCP in that several methods can be overloaded (from pure Python) to
modify the behavior of the algorithm and/or create custom algorithms
based on MCP. Note that goal_reached can also be overloaded in the
MCP class.</p>
<dl class="method">
<dt id="skimage.graph.MCP_Flexible.__init__">
<tt class="descname">__init__</tt><big>(</big><em>costs</em>, <em>offsets=None</em>, <em>fully_connected=True</em>, <em>sampling=None</em><big>)</big><a class="headerlink" href="#skimage.graph.MCP_Flexible.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>See class documentation.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.graph.MCP_Flexible.examine_neighbor">
<tt class="descname">examine_neighbor</tt><big>(</big><em>index</em>, <em>new_index</em>, <em>offset_length</em><big>)</big><a class="headerlink" href="#skimage.graph.MCP_Flexible.examine_neighbor" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called once for every pair of neighboring nodes,
as soon as both nodes are frozen.</p>
<p>This method can be overloaded to obtain information about
neightboring nodes, and/or to modify the behavior of the MCP
algorithm. One example is the MCP_Connect class, which checks
for meeting fronts using this hook.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.graph.MCP_Flexible.travel_cost">
<tt class="descname">travel_cost</tt><big>(</big><em>old_cost</em>, <em>new_cost</em>, <em>offset_length</em><big>)</big><a class="headerlink" href="#skimage.graph.MCP_Flexible.travel_cost" title="Permalink to this definition">¶</a></dt>
<dd><p>This method calculates the travel cost for going from the
current node to the next. The default implementation returns
new_cost. Overload this method to adapt the behaviour of the
algorithm.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.graph.MCP_Flexible.update_node">
<tt class="descname">update_node</tt><big>(</big><em>index</em>, <em>new_index</em>, <em>offset_length</em><big>)</big><a class="headerlink" href="#skimage.graph.MCP_Flexible.update_node" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called when a node is updated, right after
new_index is pushed onto the heap and the traceback map is
updated.</p>
<p>This method can be overloaded to keep track of other arrays
that are used by a specific implementation of the algorithm.
For instance the MCP_Connect class uses it to update an id map.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="mcp-geometric">
<h2><a class="reference internal" href="#skimage.graph.MCP_Geometric" title="skimage.graph.MCP_Geometric"><tt class="xref py py-class docutils literal"><span class="pre">MCP_Geometric</span></tt></a><a class="headerlink" href="#mcp-geometric" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.graph.MCP_Geometric">
<em class="property">class </em><tt class="descclassname">skimage.graph.</tt><tt class="descname">MCP_Geometric</tt><big>(</big><em>costs</em>, <em>offsets=None</em>, <em>fully_connected=True</em>, <em>sampling=None</em><big>)</big><a class="headerlink" href="#skimage.graph.MCP_Geometric" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">skimage.graph._mcp.MCP</span></tt></p>
<p>Find distance-weighted minimum cost paths through an n-d costs array.</p>
<p>See the documentation for MCP for full details. This class differs from
MCP in that the cost of a path is not simply the sum of the costs along
that path.</p>
<p>This class instead assumes that the costs array contains at each position
the &#8220;cost&#8221; of a unit distance of travel through that position. For
example, a move (in 2-d) from (1, 1) to (1, 2) is assumed to originate in
the center of the pixel (1, 1) and terminate in the center of (1, 2). The
entire move is of distance 1, half through (1, 1) and half through (1, 2);
thus the cost of that move is <cite>(1/2)*costs[1,1] + (1/2)*costs[1,2]</cite>.</p>
<p>On the other hand, a move from (1, 1) to (2, 2) is along the diagonal and
is sqrt(2) in length. Half of this move is within the pixel (1, 1) and the
other half in (2, 2), so the cost of this move is calculated as
<cite>(sqrt(2)/2)*costs[1,1] + (sqrt(2)/2)*costs[2,2]</cite>.</p>
<p>These calculations don&#8217;t make a lot of sense with offsets of magnitude
greater than 1. Use the <cite>sampling</cite> argument in order to deal with
anisotropic data.</p>
<dl class="method">
<dt id="skimage.graph.MCP_Geometric.__init__">
<tt class="descname">__init__</tt><big>(</big><em>costs</em>, <em>offsets=None</em>, <em>fully_connected=True</em>, <em>sampling=None</em><big>)</big><a class="headerlink" href="#skimage.graph.MCP_Geometric.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>See class documentation.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="rag">
<h2><a class="reference internal" href="#skimage.graph.RAG" title="skimage.graph.RAG"><tt class="xref py py-class docutils literal"><span class="pre">RAG</span></tt></a><a class="headerlink" href="#rag" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="skimage.graph.RAG">
<em class="property">class </em><tt class="descclassname">skimage.graph.</tt><tt class="descname">RAG</tt><big>(</big><em>data=None</em>, <em>**attr</em><big>)</big><a class="headerlink" href="#skimage.graph.RAG" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">networkx.classes.graph.Graph</span></tt></p>
<p>The Region Adjacency Graph (RAG) of an image, subclasses
<a class="reference external" href="http://networkx.github.io/documentation/latest/reference/classes.graph.html">networx.Graph</a></p>
<dl class="method">
<dt id="skimage.graph.RAG.__init__">
<tt class="descname">__init__</tt><big>(</big><em>data=None</em>, <em>**attr</em><big>)</big><a class="headerlink" href="#skimage.graph.RAG.__init__" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="skimage.graph.RAG.add_edge">
<tt class="descname">add_edge</tt><big>(</big><em>u</em>, <em>v</em>, <em>attr_dict=None</em>, <em>**attr</em><big>)</big><a class="headerlink" href="#skimage.graph.RAG.add_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>Add an edge between <cite>u</cite> and <cite>v</cite> while updating max node id.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">networkx.Graph.add_edge()</span></tt>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="skimage.graph.RAG.add_node">
<tt class="descname">add_node</tt><big>(</big><em>n</em>, <em>attr_dict=None</em>, <em>**attr</em><big>)</big><a class="headerlink" href="#skimage.graph.RAG.add_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Add node <cite>n</cite> while updating the maximum node id.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">networkx.Graph.add_node()</span></tt>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="skimage.graph.RAG.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.graph.RAG.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the graph with its max node id.</p>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><tt class="xref py py-func docutils literal"><span class="pre">networkx.Graph.copy()</span></tt>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="skimage.graph.RAG.merge_nodes">
<tt class="descname">merge_nodes</tt><big>(</big><em>src</em>, <em>dst</em>, <em>weight_func=&lt;function min_weight at 0x7f3571c5b8c0&gt;</em>, <em>in_place=True</em>, <em>extra_arguments=</em>, <span class="optional">[</span><span class="optional">]</span><em>extra_keywords={}</em><big>)</big><a class="headerlink" href="#skimage.graph.RAG.merge_nodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Merge node <cite>src</cite> and <cite>dst</cite>.</p>
<p>The new combined node is adjacent to all the neighbors of <cite>src</cite>
and <cite>dst</cite>. <cite>weight_func</cite> is called to decide the weight of edges
incident on the new node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>src, dst</strong> : int</p>
<blockquote>
<div><p>Nodes to be merged.</p>
</div></blockquote>
<p><strong>weight_func</strong> : callable, optional</p>
<blockquote>
<div><p>Function to decide edge weight of edges incident on the new node.
For each neighbor <cite>n</cite> for <cite>src and `dst</cite>, <cite>weight_func</cite> will be
called as follows: <cite>weight_func(src, dst, n, *extra_arguments,
**extra_keywords)</cite>. <cite>src</cite>, <cite>dst</cite> and <cite>n</cite> are IDs of vertices in the
RAG object which is in turn a subclass of
<cite>networkx.Graph</cite>.</p>
</div></blockquote>
<p><strong>in_place</strong> : bool, optional</p>
<blockquote>
<div><p>If set to <cite>True</cite>, the merged node has the id <cite>dst</cite>, else merged
node has a new id which is returned.</p>
</div></blockquote>
<p><strong>extra_arguments</strong> : sequence, optional</p>
<blockquote>
<div><p>The sequence of extra positional arguments passed to
<cite>weight_func</cite>.</p>
</div></blockquote>
<p><strong>extra_keywords</strong> : dictionary, optional</p>
<blockquote>
<div><p>The dict of keyword arguments passed to the <cite>weight_func</cite>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>id</strong> : int</p>
<blockquote class="last">
<div><p>The id of the new node.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Notes</p>
<p>If <cite>in_place</cite> is <cite>False</cite> the resulting node has a new id, rather than
<cite>dst</cite>.</p>
</dd></dl>

<dl class="method">
<dt id="skimage.graph.RAG.next_id">
<tt class="descname">next_id</tt><big>(</big><big>)</big><a class="headerlink" href="#skimage.graph.RAG.next_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <cite>id</cite> for the new node to be inserted.</p>
<p>The current implementation returns one more than the maximum <cite>id</cite>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>id</strong> : int</p>
<blockquote class="last">
<div><p>The <cite>id</cite> of the new node to be inserted.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#skimage.graph.cut_normalized" title="skimage.graph.cut_normalized"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.graph.cut_normalized</span></tt></a>(labels,&nbsp;rag[,&nbsp;...])</td>
<td>Perform Normalized Graph cut on the Region Adjacency Graph.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.graph.cut_threshold" title="skimage.graph.cut_threshold"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.graph.cut_threshold</span></tt></a>(labels,&nbsp;rag,&nbsp;thresh)</td>
<td>Combine regions seperated by weight less than threshold.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.graph.draw_rag" title="skimage.graph.draw_rag"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.graph.draw_rag</span></tt></a>(labels,&nbsp;rag,&nbsp;img[,&nbsp;...])</td>
<td>Draw a Region Adjacency Graph on an image.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.graph.ncut" title="skimage.graph.ncut"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.graph.ncut</span></tt></a>(labels,&nbsp;rag[,&nbsp;thresh,&nbsp;...])</td>
<td>Perform Normalized Graph cut on the Region Adjacency Graph.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.graph.rag_mean_color" title="skimage.graph.rag_mean_color"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.graph.rag_mean_color</span></tt></a>(image,&nbsp;labels)</td>
<td>Compute the Region Adjacency Graph using mean colors.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#skimage.graph.route_through_array" title="skimage.graph.route_through_array"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.graph.route_through_array</span></tt></a>(array,&nbsp;...)</td>
<td>Simple example of how to use the MCP and MCP_Geometric classes.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#skimage.graph.shortest_path" title="skimage.graph.shortest_path"><tt class="xref py py-obj docutils literal"><span class="pre">skimage.graph.shortest_path</span></tt></a>(arr[,&nbsp;reach,&nbsp;...])</td>
<td>Find the shortest path through an n-d array from one side to another.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cut-normalized">
<h2>cut_normalized<a class="headerlink" href="#cut-normalized" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.graph.cut_normalized">
<tt class="descclassname">skimage.graph.</tt><tt class="descname">cut_normalized</tt><big>(</big><em>labels</em>, <em>rag</em>, <em>thresh=0.001</em>, <em>num_cuts=10</em>, <em>in_place=True</em>, <em>max_edge=1.0</em><big>)</big><a class="headerlink" href="#skimage.graph.cut_normalized" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform Normalized Graph cut on the Region Adjacency Graph.</p>
<p>Given an image&#8217;s labels and its similarity RAG, recursively perform
a 2-way normalized cut on it. All nodes belonging to a subgraph
that cannot be cut further are assigned a unique label in the
output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>labels</strong> : ndarray</p>
<blockquote>
<div><p>The array of labels.</p>
</div></blockquote>
<p><strong>rag</strong> : RAG</p>
<blockquote>
<div><p>The region adjacency graph.</p>
</div></blockquote>
<p><strong>thresh</strong> : float</p>
<blockquote>
<div><p>The threshold. A subgraph won&#8217;t be further subdivided if the
value of the N-cut exceeds <cite>thresh</cite>.</p>
</div></blockquote>
<p><strong>num_cuts</strong> : int</p>
<blockquote>
<div><p>The number or N-cuts to perform before determining the optimal one.</p>
</div></blockquote>
<p><strong>in_place</strong> : bool</p>
<blockquote>
<div><p>If set, modifies <cite>rag</cite> in place. For each node <cite>n</cite> the function will
set a new attribute <tt class="docutils literal"><span class="pre">rag.node[n]['ncut</span> <span class="pre">label']</span></tt>.</p>
</div></blockquote>
<p><strong>max_edge</strong> : float, optional</p>
<blockquote>
<div><p>The maximum possible value of an edge in the RAG. This corresponds to
an edge between identical regions. This is used to put self
edges in the RAG.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : ndarray</p>
<blockquote class="last">
<div><p>The new labeled array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r200" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[R200]</a></td><td>Shi, J.; Malik, J., &#8220;Normalized cuts and image segmentation&#8221;,
Pattern Analysis and Machine Intelligence,
IEEE Transactions on, vol. 22, no. 8, pp. 888-905, August 2000.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">segmentation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">segmentation</span><span class="o">.</span><span class="n">slic</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">compactness</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">n_segments</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rag</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">rag_mean_color</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;similarity&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_labels</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">cut_normalized</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">rag</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="cut-threshold">
<h2>cut_threshold<a class="headerlink" href="#cut-threshold" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.graph.cut_threshold">
<tt class="descclassname">skimage.graph.</tt><tt class="descname">cut_threshold</tt><big>(</big><em>labels</em>, <em>rag</em>, <em>thresh</em>, <em>in_place=True</em><big>)</big><a class="headerlink" href="#skimage.graph.cut_threshold" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine regions seperated by weight less than threshold.</p>
<p>Given an image&#8217;s labels and its RAG, output new labels by
combining regions whose nodes are seperated by a weight less
than the given threshold.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>labels</strong> : ndarray</p>
<blockquote>
<div><p>The array of labels.</p>
</div></blockquote>
<p><strong>rag</strong> : RAG</p>
<blockquote>
<div><p>The region adjacency graph.</p>
</div></blockquote>
<p><strong>thresh</strong> : float</p>
<blockquote>
<div><p>The threshold. Regions connected by edges with smaller weights are
combined.</p>
</div></blockquote>
<p><strong>in_place</strong> : bool</p>
<blockquote>
<div><p>If set, modifies <cite>rag</cite> in place. The function will remove the edges
with weights less that <cite>thresh</cite>. If set to <cite>False</cite> the function
makes a copy of <cite>rag</cite> before proceeding.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : ndarray</p>
<blockquote class="last">
<div><p>The new labelled array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r201" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[R201]</a></td><td>Alain Tremeau and Philippe Colantoni
&#8220;Regions Adjacency Graph Applied To Color Image Segmentation&#8221;
<a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.11.5274">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.11.5274</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">segmentation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">segmentation</span><span class="o">.</span><span class="n">slic</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rag</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">rag_mean_color</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_labels</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">cut_threshold</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">rag</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="draw-rag">
<h2>draw_rag<a class="headerlink" href="#draw-rag" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.graph.draw_rag">
<tt class="descclassname">skimage.graph.</tt><tt class="descname">draw_rag</tt><big>(</big><em>labels</em>, <em>rag</em>, <em>img</em>, <em>border_color=None</em>, <em>node_color='#ffff00'</em>, <em>edge_color='#00ff00'</em>, <em>colormap=None</em>, <em>thresh=inf</em>, <em>desaturate=False</em>, <em>in_place=True</em><big>)</big><a class="headerlink" href="#skimage.graph.draw_rag" title="Permalink to this definition">¶</a></dt>
<dd><p>Draw a Region Adjacency Graph on an image.</p>
<p>Given a labelled image and its corresponding RAG, draw the nodes and edges
of the RAG on the image with the specified colors. Nodes are marked by
the centroids of the corresponding regions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>labels</strong> : ndarray, shape (M, N)</p>
<blockquote>
<div><p>The labelled image.</p>
</div></blockquote>
<p><strong>rag</strong> : RAG</p>
<blockquote>
<div><p>The Region Adjacency Graph.</p>
</div></blockquote>
<p><strong>img</strong> : ndarray, shape (M, N, 3)</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>border_color</strong> : colorspec, optional</p>
<blockquote>
<div><p>Any matplotlib colorspec.</p>
</div></blockquote>
<p><strong>node_color</strong> : colorspec, optional</p>
<blockquote>
<div><p>Any matplotlib colorspec. Yellow by default.</p>
</div></blockquote>
<p><strong>edge_color</strong> : colorspec, optional</p>
<blockquote>
<div><p>Any matplotlib colorspec. Green by default.</p>
</div></blockquote>
<p><strong>colormap</strong> : colormap, optional</p>
<blockquote>
<div><p>Any matplotlib colormap. If specified the edges are colormapped with
the specified color map.</p>
</div></blockquote>
<p><strong>thresh</strong> : float, optional</p>
<blockquote>
<div><p>Edges with weight below <cite>thresh</cite> are not drawn, or considered for color
mapping.</p>
</div></blockquote>
<p><strong>desaturate</strong> : bool, optional</p>
<blockquote>
<div><p>Convert the image to grayscale before displaying. Particularly helps
visualization when using the <cite>colormap</cite> option.</p>
</div></blockquote>
<p><strong>in_place</strong> : bool, optional</p>
<blockquote>
<div><p>If set, the RAG is modified in place. For each node <cite>n</cite> the function
will set a new attribute <tt class="docutils literal"><span class="pre">rag.node[n]['centroid']</span></tt>.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : ndarray, shape (M, N, 3)</p>
<blockquote class="last">
<div><p>The image with the RAG drawn.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">segmentation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">coffee</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">segmentation</span><span class="o">.</span><span class="n">slic</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span>  <span class="n">graph</span><span class="o">.</span><span class="n">rag_mean_color</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">draw_rag</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="ncut">
<h2>ncut<a class="headerlink" href="#ncut" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.graph.ncut">
<tt class="descclassname">skimage.graph.</tt><tt class="descname">ncut</tt><big>(</big><em>labels</em>, <em>rag</em>, <em>thresh=0.001</em>, <em>num_cuts=10</em>, <em>in_place=True</em>, <em>max_edge=1.0</em><big>)</big><a class="headerlink" href="#skimage.graph.ncut" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform Normalized Graph cut on the Region Adjacency Graph.</p>
<p>Given an image&#8217;s labels and its similarity RAG, recursively perform
a 2-way normalized cut on it. All nodes belonging to a subgraph
that cannot be cut further are assigned a unique label in the
output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>labels</strong> : ndarray</p>
<blockquote>
<div><p>The array of labels.</p>
</div></blockquote>
<p><strong>rag</strong> : RAG</p>
<blockquote>
<div><p>The region adjacency graph.</p>
</div></blockquote>
<p><strong>thresh</strong> : float</p>
<blockquote>
<div><p>The threshold. A subgraph won&#8217;t be further subdivided if the
value of the N-cut exceeds <cite>thresh</cite>.</p>
</div></blockquote>
<p><strong>num_cuts</strong> : int</p>
<blockquote>
<div><p>The number or N-cuts to perform before determining the optimal one.</p>
</div></blockquote>
<p><strong>in_place</strong> : bool</p>
<blockquote>
<div><p>If set, modifies <cite>rag</cite> in place. For each node <cite>n</cite> the function will
set a new attribute <tt class="docutils literal"><span class="pre">rag.node[n]['ncut</span> <span class="pre">label']</span></tt>.</p>
</div></blockquote>
<p><strong>max_edge</strong> : float, optional</p>
<blockquote>
<div><p>The maximum possible value of an edge in the RAG. This corresponds to
an edge between identical regions. This is used to put self
edges in the RAG.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : ndarray</p>
<blockquote class="last">
<div><p>The new labeled array.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r202" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[R202]</a></td><td>Shi, J.; Malik, J., &#8220;Normalized cuts and image segmentation&#8221;,
Pattern Analysis and Machine Intelligence,
IEEE Transactions on, vol. 22, no. 8, pp. 888-905, August 2000.</td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">segmentation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">segmentation</span><span class="o">.</span><span class="n">slic</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">compactness</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">n_segments</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rag</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">rag_mean_color</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;similarity&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_labels</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">cut_normalized</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">rag</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="rag-mean-color">
<h2>rag_mean_color<a class="headerlink" href="#rag-mean-color" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.graph.rag_mean_color">
<tt class="descclassname">skimage.graph.</tt><tt class="descname">rag_mean_color</tt><big>(</big><em>image</em>, <em>labels</em>, <em>connectivity=2</em>, <em>mode='distance'</em>, <em>sigma=255.0</em><big>)</big><a class="headerlink" href="#skimage.graph.rag_mean_color" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the Region Adjacency Graph using mean colors.</p>
<p>Given an image and its initial segmentation, this method constructs the
corresponsing Region Adjacency Graph (RAG). Each node in the RAG
represents a set of pixels within <cite>image</cite> with the same label in <cite>labels</cite>.
The weight between two adjacent regions represents how similar or
dissimilar two regions are depending on the <cite>mode</cite> parameter.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>image</strong> : ndarray, shape(M, N, [..., P,] 3)</p>
<blockquote>
<div><p>Input image.</p>
</div></blockquote>
<p><strong>labels</strong> : ndarray, shape(M, N, [..., P,])</p>
<blockquote>
<div><p>The labelled image. This should have one dimension less than
<cite>image</cite>. If <cite>image</cite> has dimensions <cite>(M, N, 3)</cite> <cite>labels</cite> should have</p>
<blockquote>
<div><p>dimensions <cite>(M, N)</cite>.</p>
</div></blockquote>
</div></blockquote>
<p><strong>connectivity</strong> : int, optional</p>
<blockquote>
<div><p>Pixels with a squared distance less than <cite>connectivity</cite> from each other
are considered adjacent. It can range from 1 to <cite>labels.ndim</cite>. Its
behavior is the same as <cite>connectivity</cite> parameter in
<cite>scipy.ndimage.filters.generate_binary_structure</cite>.</p>
</div></blockquote>
<p><strong>mode</strong> : {&#8216;distance&#8217;, &#8216;similarity&#8217;}, optional</p>
<blockquote>
<div><p>The strategy to assign edge weights.</p>
<blockquote>
<div><p>&#8216;distance&#8217; : The weight between two adjacent regions is the
<img class="math" src="../_images/math/987a5a25be1cbb2c8d66e13c581eeab8443be702.png" alt="|c_1 - c_2|"/>, where <img class="math" src="../_images/math/3b3656365ff2748ee55de15a942b63693cb47dae.png" alt="c_1"/> and <img class="math" src="../_images/math/5081ba4156b5c83e0ad11d0dbf1ddd83fa988929.png" alt="c_2"/> are the mean
colors of the two regions. It represents the Euclidean distance in
their average color.</p>
<p>&#8216;similarity&#8217; : The weight between two adjacent is
<img class="math" src="../_images/math/d65b04357dbea2c9506643b7d0ca235ab4a66d81.png" alt="e^{-d^2/sigma}"/> where <img class="math" src="../_images/math/dc1383929c07a5f92772a6db397064a0b72f89e9.png" alt="d=|c_1 - c_2|"/>, where
<img class="math" src="../_images/math/3b3656365ff2748ee55de15a942b63693cb47dae.png" alt="c_1"/> and <img class="math" src="../_images/math/5081ba4156b5c83e0ad11d0dbf1ddd83fa988929.png" alt="c_2"/> are the mean colors of the two regions.
It represents how similar two regions are.</p>
</div></blockquote>
</div></blockquote>
<p><strong>sigma</strong> : float, optional</p>
<blockquote>
<div><p>Used for computation when <cite>mode</cite> is &#8220;similarity&#8221;. It governs how
close to each other two colors should be, for their corresponding edge
weight to be significant. A very large value of <cite>sigma</cite> could make
any two colors behave as though they were similar.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>out</strong> : RAG</p>
<blockquote class="last">
<div><p>The region adjacency graph.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">References</p>
<table class="docutils citation" frame="void" id="r203" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[R203]</a></td><td>Alain Tremeau and Philippe Colantoni
&#8220;Regions Adjacency Graph Applied To Color Image Segmentation&#8221;
<a class="reference external" href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.11.5274">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.11.5274</a></td></tr>
</tbody>
</table>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">data</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">segmentation</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">astronaut</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">segmentation</span><span class="o">.</span><span class="n">slic</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rag</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">rag_mean_color</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="route-through-array">
<h2>route_through_array<a class="headerlink" href="#route-through-array" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.graph.route_through_array">
<tt class="descclassname">skimage.graph.</tt><tt class="descname">route_through_array</tt><big>(</big><em>array</em>, <em>start</em>, <em>end</em>, <em>fully_connected=True</em>, <em>geometric=True</em><big>)</big><a class="headerlink" href="#skimage.graph.route_through_array" title="Permalink to this definition">¶</a></dt>
<dd><p>Simple example of how to use the MCP and MCP_Geometric classes.</p>
<p>See the MCP and MCP_Geometric class documentation for explanation of the
path-finding algorithm.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>array</strong> : ndarray</p>
<blockquote>
<div><p>Array of costs.</p>
</div></blockquote>
<p><strong>start</strong> : iterable</p>
<blockquote>
<div><p>n-d index into <cite>array</cite> defining the starting point</p>
</div></blockquote>
<p><strong>end</strong> : iterable</p>
<blockquote>
<div><p>n-d index into <cite>array</cite> defining the end point</p>
</div></blockquote>
<p><strong>fully_connected</strong> : bool (optional)</p>
<blockquote>
<div><p>If True, diagonal moves are permitted, if False, only axial moves.</p>
</div></blockquote>
<p><strong>geometric</strong> : bool (optional)</p>
<blockquote>
<div><p>If True, the MCP_Geometric class is used to calculate costs, if False,
the MCP base class is used. See the class documentation for
an explanation of the differences between MCP and MCP_Geometric.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>path</strong> : list</p>
<blockquote>
<div><p>List of n-d index tuples defining the path from <cite>start</cite> to <cite>end</cite>.</p>
</div></blockquote>
<p><strong>cost</strong> : float</p>
<blockquote class="last">
<div><p>Cost of the path. If <cite>geometric</cite> is False, the cost of the path is
the sum of the values of <cite>array</cite> along the path. If <cite>geometric</cite> is
True, a finer computation is made (see the documentation of the
MCP_Geometric class).</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="#skimage.graph.MCP" title="skimage.graph.MCP"><tt class="xref py py-obj docutils literal"><span class="pre">MCP</span></tt></a>, <a class="reference internal" href="#skimage.graph.MCP_Geometric" title="skimage.graph.MCP_Geometric"><tt class="xref py py-obj docutils literal"><span class="pre">MCP_Geometric</span></tt></a></p>
</div>
<p class="rubric">Examples</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">skimage.graph</span> <span class="kn">import</span> <span class="n">route_through_array</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span>
<span class="go">array([[ 1,  3],</span>
<span class="go">       [10, 12]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Forbid diagonal steps</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">route_through_array</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">fully_connected</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">([(0, 0), (0, 1), (1, 1)], 9.5)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Now allow diagonal steps: the path goes directly from start to end</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">route_through_array</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="go">([(0, 0), (1, 1)], 9.1923881554251192)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Cost is the sum of array values along the path (16 = 1 + 3 + 12)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">route_through_array</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">fully_connected</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
<span class="gp">... </span><span class="n">geometric</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
<span class="go">([(0, 0), (0, 1), (1, 1)], 16.0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Larger array where we display the path that is selected</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">((</span><span class="mi">36</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image</span>
<span class="go">array([[ 0,  1,  2,  3,  4,  5],</span>
<span class="go">       [ 6,  7,  8,  9, 10, 11],</span>
<span class="go">       [12, 13, 14, 15, 16, 17],</span>
<span class="go">       [18, 19, 20, 21, 22, 23],</span>
<span class="go">       [24, 25, 26, 27, 28, 29],</span>
<span class="go">       [30, 31, 32, 33, 34, 35]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Find the path with lowest cost</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">route_through_array</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">path</span>
<span class="go">array([[1, 1, 1, 1, 1, 0],</span>
<span class="go">       [0, 0, 0, 0, 0, 1],</span>
<span class="go">       [0, 0, 0, 0, 0, 1],</span>
<span class="go">       [0, 0, 0, 0, 0, 1],</span>
<span class="go">       [0, 0, 0, 0, 0, 1],</span>
<span class="go">       [0, 0, 0, 0, 0, 1]])</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="shortest-path">
<h2>shortest_path<a class="headerlink" href="#shortest-path" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="skimage.graph.shortest_path">
<tt class="descclassname">skimage.graph.</tt><tt class="descname">shortest_path</tt><big>(</big><em>arr</em>, <em>reach=1</em>, <em>axis=-1</em>, <em>output_indexlist=False</em><big>)</big><a class="headerlink" href="#skimage.graph.shortest_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the shortest path through an n-d array from one side to another.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><p class="first"><strong>arr</strong> : ndarray of float64</p>
<p><strong>reach</strong> : int, optional</p>
<blockquote>
<div><p>By default (<tt class="docutils literal"><span class="pre">reach</span> <span class="pre">=</span> <span class="pre">1</span></tt>), the shortest path can only move
one row up or down for every step it moves forward (i.e.,
the path gradient is limited to 1). <cite>reach</cite> defines the
number of elements that can be skipped along each non-axis
dimension at each step.</p>
</div></blockquote>
<p><strong>axis</strong> : int, optional</p>
<blockquote>
<div><p>The axis along which the path must always move forward (default -1)</p>
</div></blockquote>
<p><strong>output_indexlist: bool, optional</strong> :</p>
<blockquote>
<div><p>See return value <cite>p</cite> for explanation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><strong>p</strong> : iterable of int</p>
<blockquote>
<div><p>For each step along <cite>axis</cite>, the coordinate of the shortest path.
If <cite>output_indexlist</cite> is True, then the path is returned as a list of
n-d tuples that index into <cite>arr</cite>. If False, then the path is returned
as an array listing the coordinates of the path along the non-axis
dimensions for each step along the axis dimension. That is,
<cite>p.shape == (arr.shape[axis], arr.ndim-1)</cite> except that p is squeezed
before returning so if <cite>arr.ndim == 2</cite>, then
<cite>p.shape == (arr.shape[axis],)</cite></p>
</div></blockquote>
<p><strong>cost</strong> : float</p>
<blockquote class="last">
<div><p>Cost of path.  This is the absolute sum of all the
differences along the path.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


        </div>
        <div class="span3"><h4 class="sidebar-box-heading">Navigation</h4>
<div class="well sidebar-box">
    <ul class="nav nav-list">
        <li><a href="../index.html">Documentation Home</a></li>
    </ul>
</div>
        <h4 class="sidebar-box-heading">Contents</h4>
        <div class="well sidebar-box toc">
            <ul class="nav nav-list">
<li><a class="reference internal" href="#">Module: <tt class="docutils literal"><span class="pre">graph</span></tt></a><ul class="nav nav-list">
<li><a class="reference internal" href="#mcp"><tt class="docutils literal"><span class="pre">MCP</span></tt></a></li>
<li><a class="reference internal" href="#mcp-connect"><tt class="docutils literal"><span class="pre">MCP_Connect</span></tt></a></li>
<li><a class="reference internal" href="#mcp-flexible"><tt class="docutils literal"><span class="pre">MCP_Flexible</span></tt></a></li>
<li><a class="reference internal" href="#mcp-geometric"><tt class="docutils literal"><span class="pre">MCP_Geometric</span></tt></a></li>
<li><a class="reference internal" href="#rag"><tt class="docutils literal"><span class="pre">RAG</span></tt></a></li>
<li><a class="reference internal" href="#cut-normalized">cut_normalized</a></li>
<li><a class="reference internal" href="#cut-threshold">cut_threshold</a></li>
<li><a class="reference internal" href="#draw-rag">draw_rag</a></li>
<li><a class="reference internal" href="#ncut">ncut</a></li>
<li><a class="reference internal" href="#rag-mean-color">rag_mean_color</a></li>
<li><a class="reference internal" href="#route-through-array">route_through_array</a></li>
<li><a class="reference internal" href="#shortest-path">shortest_path</a></li>
</ul>
</li>
</ul>

        </div>

<h4 class="sidebar-box-heading">Versions</h4>
<div class="well sidebar-box">
    <ul class="nav nav-list">
        <script src="../_static/docversions.js"></script>
        <script type="text/javascript">
            insert_version_links();
        </script>
    </ul>
</div>
        </div>
    </div>
    <div class="well footer">
        <small>
            &copy; Copyright the scikit-image development team.
            Created using <a href="http://twitter.github.com/bootstrap/">Bootstrap</a> and <a href="http://sphinx.pocoo.org/">Sphinx</a>.
        </small>
    </div>
</body>
</html>